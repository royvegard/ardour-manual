<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % dbcent PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN"
   "/usr/share/xml/docbook/schema/dtd/4.5/dbcentx.mod">
%dbcent;
<!ENTITY modone "Ctrl">
<!ENTITY modtwo "Alt">
<!ENTITY modtertiary "Shift">
<!ENTITY % extensions SYSTEM "extensions.ent">
%extensions;
]>
<book xmlns="http://docbook.org/ns/docbook" version="5.0" xml:lang="en">

<bookinfo>
<title>Ardour 3 &mdash; a users&rsquo; guide</title>
<author><firstname>Paul</firstname><surname>Davis</surname></author>
<author><firstname>Carl</firstname><surname>Hetherington</surname></author>
</bookinfo>

<!-- XXX
external sync
connection management/routing
snapshots
undo/redo, how it doesn't work with, say, mixer settings
control surfaces
recording (basics)
-->

<!--
\titlepic{\includegraphics{graphics/ardour_bw.pdf}}
\author{Paul Davis\\Carl Hetherington}
\date{}
\begin{document}

-->


<!-- ====================================================================================
     INTRODUCTION
     ==================================================================================== -->

<chapter>
<title>Introduction</title>

<para>
Hello, and welcome to Ardour!
</para>

<section>
<title>What is Ardour?</title>

<para>
Ardour is an open-source digital audio workstation (DAW) for Linux and
Mac OS X.
</para>

</section>

<section>
<title>Typographical conventions</title>

<para>
This manual uses special symbols to denote sections which contain
advanced material.  The reader can skip these sections without any
great loss.
</para>

<sidebar>
<para>
Tricky parts of the text are formatted like this.  They contain extra
information which may be of interest to advanced users.
</para>
</sidebar>

</section>




<section>
<title>About this manual</title>

<para>
This manual is a work-in-progress.  In other words, it is not even
close to being complete.  Any suggestions for improvements, content,
or comments on parts that do not make sense are welcome to
<ulink url="mailto:cth@carlh.net">cth@carlh.net</ulink>.
</para>

<sidebar>
<para>
For those familiar with &lsquo;git&rsquo;, the manual's DocBook source can be
obtained from the git repository linked from <ulink
url="http://carlh.net/ardour">http://carlh.net/ardour</ulink>.
Patches to the manual are most welcome.
</para>
</sidebar>

</section>

<section>
<title>Getting help with Ardour</title>

<para>
There are several places that you can get help with using Ardour.
</para>


<section>
<title>The website</title>

<para>
Ardour's website (<ulink url="http://ardour.org/">http://ardour.org</ulink>) contains many
useful resources, including a list of frequently-asked questions, a
forum and a bug and feature request tracker.
</para>

</section>

<section>
<title>IRC</title>
<indexterm><primary>IRC</primary></indexterm>

<para>
Ardour's core developers and several key users are usually to be found
on Internet Relay Chat (IRC) on <ulink url="irc://irc.freenode.net">irc.freenode.net</ulink> in #ardour and
#ardour-osx at pretty much any hour of the day or night.  This is a
live chat system that is great for dicussing Ardour's development,
design, and also user problems.  There are IRC clients for most
operating systems, or you can join in directly from your web browser
by choosing <guimenuitem>Chat</guimenuitem> from the Ardour's <guimenu>Help</guimenu> menu.
</para>

<para>
If you join the IRC rooms, here are a few tips:

<itemizedlist>
<listitem>
<emphasis>Don't ask to ask, just ask</emphasis> &mdash; rather than saying &lsquo;Is it
  ok if I ask a question?&rsquo;, just ask your question &mdash; it is not
  considered rude to do so.  Then wait: your answer may come in
  seconds, minutes, hours or never, depending on who is around and
  what time of the day it is wherever they happen to be in the world.
  In particular, make sure you <emphasis>do</emphasis> wait; do not get upset if you
  don't get an answer straight away.
</listitem>
<listitem>
<emphasis>Don't be offended if no-one replies</emphasis> &mdash; although other
  users may be logged into the channel, they may well be coding
  Ardour, cooking, reading XKCD, cleaning their ostrabagalous devices,
  or any number of other things.
</listitem>
<listitem>
<emphasis>Don't paste large amounts of text into the
channel</emphasis> &mdash; if you have more than a couple of lines of
output from some command that you want to show everyone, use a site
like <olink url="http://pastebin/com">pastebin.com</olink> You can
copy your text into that site, and it will give you a web address that
you can paste into the channel.
</listitem>
<listitem>
<emphasis>Be as detailed as possible</emphasis> &mdash; if you have a problem,
  tell us what version of Ardour you are using, and what operating
  system you are running on (Linux, OS X or Windows).
</listitem>
</itemizedlist>
</para>

</section>


<section>
<title>Mailing lists</title>

There is a Ardour users mailing list, where various discussions about
Ardour (and recording in general) take place.  There are links to join
the list on Ardour's website.

</section>

<section>
<title>Support expectations</title>

<para>
As Ardour evolves, it becomes a serious alternative to commercial
products for more and more people. We see the download counts increase
for each new release, and the volume of traffic on the mailing lists
is growing. That's lovely, of course. We work on Ardour without the
accoutrements of a &lsquo;normal&rsquo; software corporation, so whenever a new
user finds our work useful and worthwile, it makes what we do seem
meaningful and worth continuing with.
</para>

<para>
Unfortunately, it's not all roses we receive.  With wider public
interest and more users, there's bound to be people who are
disappointed in Ardour. We believe, however, that it's only because
most newcomers do not realize what to expect.
</para>


<section>
<title>The development team</title>

<para>
Many users probably don't realize it, but the development team driving
Ardour forward is very small for the amazingly complex piece of
software that is a contemporary DAW.
</para>

<para>
At this time, the main force behind Ardour is delivered by one person,
with core aid from two others, and contributions from on the order of
a dozen others. Consider that we do support, web site maintenance,
documentation, feature enhancements, debugging, as well as
development.
</para>

<para>
There are more people (perhaps another dozen) pitching in with
translation, release engineering (preparing Ardour for users), Mantis
triaging (&lsquo;Mantis&rsquo; is the bug database used to keep track of known
problems, &lsquo;triaging&rsquo; the process of prioritizing and verifying bugs)
and other necessary tasks.
</para>

<para>
So we are always looking for new people to help, and while
(unfortunately) a common misconception is that a project like Ardour
would only benefit from more programmers, it is not the case! Whatever
your ability, we can use it. If you are interested in spending a
little time making Ardour a better DAW, please don't hesitate to join
the developer mailing list and offer your services.
</para>

</section>
<section>
<title>Ardour features and polish</title>

<para>
As Ardour is getting more powerful and usable, we attract more and
more users who expect the same feature set and product polish as
they'll find in a commercial product such as DigiDesign's ProTools or
Steinberg's Nuendo. This isn't the right way to think about Ardour at
this time.
</para>

<para>
Not that we don't want to get there, you understand, but it's simply
not a reasonable comparison. DigiDesign has spent who knows how many
man-hours worth of development on ProTools and can spend a lot on
getting good documentation written, new features, debugging,
installation process made smooth and generally polish the thing till
it shines. In comparison, Ardour development is driven primarily by
the interests of just a few people. Development is a full time job for
the lead developer, who also raises a three kids, fixes up his house,
has friends and even a relationship with a gorgeous woman.
</para>

<para>
Do not read that as an excuse for why Ardour lacks in comparison with
other products. Do read it as an explanation for why you should expect
nothing more from Ardour than it actually delivers. And rest assured
that the developers want and expect it to rival, or better yet, beat
the proprietary DAWs. That's why we're so committed to this
development model &mdash; because we believe it's the best way to get there.
</para>

</section>

<section>
<title>Releases</title>

<para>
Ardour releases are also put together by volunteers. This means that
there's usually only prebuilt binaries available for a few select
platforms. While we would like to see Ardour prebuilt for all the
platforms (and operating system versions) Ardour runs on, it's simply
not possible since the volunteers doing the release only have access
to a subset of those platforms.
</para>

<para>
With specific regards to library dependencies: depending on the
volunteer's machine configuration, the Ardour binary may require you
to install additional or newer libraries before it will work. If so,
the installation instructions should contain the necessary information
for you to find those libraries. Please do not complain about the need
for these libraries &mdash; just as you might dislike installing/upgrading
the libraries, the volunteer doing the release may dislike
removing/downgrading the libraries on her machine.
</para>

<para>
If you find that there are no prebuilt binaries for your
platform/configuration, and are willing to help provide packages for
coming releases, please join the developer mailing list and offer your
services. It is not a requirement that you are a programmer, but there
may be a requirement for (commercial) development tools which not
everyone would have access to. If you have the time and tools, we can
probably guide you through the process, even if you don't have the
knowledge.
</para>

</section>

<section>
<title>Support</title>

<para>
You can join both the user and developer mailing lists and ask
questions there. You can also ask for help on IRC, and you can file
bug reports and feature requests in Mantis. However, since support is
also provided on a volunteer basis, you must be careful not to have
unreasonable expectations: you cannot demand your questions to be
answered or bugs to be fixed. In short: the people volunteering time
to Ardour only have so much time available, and they alone decide how
to spend it. Please respect their choice.
</para>

<para>
When that is said, you should know that the mailing list and the IRC
channel are friendly places &mdash; few requests go without reply. And we
also do our best to fix all bugs reported, just as we strive to
implement requested features. But as should be evident from the number
of open bugs in Mantis, there's not enough hours in the day to allow
us to address all issues in a timely manner.
</para>

</section>
</section>
</section>
</chapter>



<!-- ====================================================================================
     OVERVIEW
     ==================================================================================== -->

<chapter>
<title>Overview</title>

<para>
As one might expect, Ardour is similar in many ways to many other DAWs
and also has its fair share of differences.  This chapter gives an
overview of Ardour.
</para>


<section>
<title>JACK</title>
<indexterm><primary>JACK</primary></indexterm>

<para>
Ardour is built on another piece of software called JACK
<footnote><para>JACK stands for the JACK Audio Connection Kit; a pleasingly recursive acronym.</para></footnote>.
JACK has two main functions; first, it moves audio and MIDI to
and from a sound card, and second, it allows audio and MIDI to be
routed between different applications.
</para>

<para>
JACK provides a great deal of flexibility and power, especially when
running other applications (such as soft-synthesizers or samplers) at
the same time as Ardour.  It is somewhat similar to Steinberg's Rewire
technology, though broader in scope.  It is even possible to use JACK
to route audio and MIDI over network connections.
</para>

<para>
JACK must be running when Ardour is, though it is possible (if you
wish) to almost ignore its existance.  At first we will let Ardour
start JACK, and not get too involved in its complications.
<xref linkend="ch-jack"/> gets into more detail for those that are
interested.
</para>

</section>

<section>
<title>Ardour concepts</title>

<para>
Ardour has its own names for the usual set of common DAW concepts.
This section briefly describes some of these concepts.
</para>


<section>
<title>Sessions</title>
<indexterm><primary>session</primary></indexterm>

<para>
An Ardour <emphasis>session</emphasis> is a container for an entire project.  A
session may contain an arbitrary number of tracks and busses
consisting of audio and MIDI data, along with information on processing
those tracks, a mix of levels, and everything else related to the
project.  A session might typically contain a song, or perhaps an entire
album or a complete live recording.
</para>

<para>
Ardour sessions are held in directories; these directories contain one
or more <emphasis>session files</emphasis>, some or all of the audio and MIDI data
and a number of other state files that Ardour requires.  The session
file describes the structure of the session, and holds automation data
and other details.
</para>

<sidebar>
<para>
Ardour's session file is kept in XML format, which is advantageous as
it is somewhat human-readable, and human-editable in a crisis.  Sound
files are stored in one of a number of optional formats, and MIDI
files as SMF (standard MIDI format).
</para>

<para>
It is also possible for Ardour sessions to reference sound and MIDI
files outside the session directory.
</para>
</sidebar>

<para>
Ardour has a single current session at all times; if Ardour is started
without specifying one, it will offer to load or create one.
</para>

</section>


<section>
<title>Tracks</title>
<indexterm><primary>track</primary></indexterm>

<para>
A track is a concept common to most DAWs, and used also in Ardour.
Tracks can record audio or MIDI data to disk, and then replay it with
processing.  They also allow the audio or MIDI data to be edited in a
variety of different ways.
</para>

<para>
In a typical pop production, one might use a track each for the kick
drum, another for the snare, more perhaps for the drum overheads and
others for bass, guitars and vocals.
</para>

<para>
Ardour can record to any number of tracks at one time, and then play
those tracks back.  On playback, a track's recordings may be processed
by any number of plugins, panned, and its level altered to achieve a
suitable mix.
</para>

<sidebar>
<para>
A track's type is really only related to the type of data that it
stores on disk.  It is possible, for example, to have a MIDI track
with a synthesizer plugin which converts MIDI to audio.  Even though
the track remains &lsquo;MIDI&rsquo;, in the sense that its on-disk recordings are
MIDI, its output may be audio-only.
</para>
</sidebar>

</section>

<section>
<title>Regions</title>
<indexterm><primary>region</primary></indexterm>

<para>
A track may contain many segments of audio or MIDI.  Ardour contains
these segments in things called <emphasis>regions</emphasis>, which are
self-contained snippets of audio or MIDI data.  Any recording pass,
for example, generates a region on each track that is enabled for
recording.  Regions can be subjected to many editing operations; they
may be moved around, split, trimmed, copied, and so on.
</para>

</section>
<section>
<title>Playlists</title>
<indexterm><primary>playlist</primary></indexterm>

<para>
The details of what exactly each track should play back is described
by a <emphasis>playlist</emphasis>.  A playlist is simply a list of regions; each
track always has an active playlist, and can have other playlists
which can be switched in and out as required.
</para>

</section>
<section>
<title>Busses</title>
<indexterm><primary>bus</primary></indexterm>

<para>
Busses are another common concept in both DAWs and hardware mixers.
They are similar in many ways to tracks; they process audio or MIDI,
and can run processing plugins.  The only difference is that their
input is obtained from other tracks or busses, rather than from disk.
</para>

<para>
One might typically use a buss to collect together the outputs of
related tracks.  Consider, for example, a 3-track recording of a
drum-kit; given kick, snare and overhead tracks, it may be helpful to
connect the output of each to a bus called &lsquo;drums&rsquo;, so that the
drum-kit's level can be set as a unit, and processing (such as
equalisation or compression) can be applied to the mix of all tracks.
</para>

</section>
<section>
<title>Plugins</title>
<indexterm><primary>plugin</primary></indexterm>

<para>
Ardour allows you to process audio and MIDI using any number of
<emphasis>plugins</emphasis>.  These are external pieces of code, commonly seen as
VST plugins on Windows or AU plugins on Mac OS X.  Generally speaking,
a plugin is written using one (and maybe more) standards.  Ardour's
plugin support is for the following standards:
</para>

<itemizedlist>
<listitem>
LADSPA<footnote><para>An acronym of "Linux Audio Developers&rsquo;
Simple Plugin API"</para></footnote> &mdash; the first major plugin
standard for Linux.  Many LADSPA plugins are availble, mostly free and
open-source. <indexterm><primary>LADSPA</primary></indexterm>
</listitem>
<listitem>
LV2
&mdash; the successor to LADSPA.  Lots of plugins have been
  &lsquo;ported&rsquo; from LADSPA to LV2, and also many new plugins written. <indexterm><primary>LV2</primary></indexterm>
</listitem>
<listitem>
VST
&mdash; Ardour supports VST plugins that have been compiled for Linux. <indexterm><primary>VST</primary></indexterm>
</listitem>
<listitem>
AU
&mdash; Mac OS X versions of Ardour support AudioUnit (AU) plugins. <indexterm><primary>AU</primary></indexterm>
</listitem>
</itemizedlist>

<para>
Ardour has some support for running Windows VST plugins on Linux, but
this is rather complicated, extremely difficult for the Ardour
developers to debug, and generally unreliable.  If it is at all
possible, you are strongly advised to use native LADSPA, LV2 or Linux
VST plugins on Linux, or AU on Mac OS X.
</para>

</section>
</section>

<section><title>The Ardour interface</title>

<para>
This section gives an overview of Ardour's main interface elements.
</para>

<section><title>The editor window</title>

<indexterm><primary>editor</primary></indexterm>

<para>
The first of Ardour's two main windows is the <emphasis>Editor</emphasis>.  A
typical editor window is shown in <xref linkend="fig-typical-editor"/>.
</para>

<figure id="fig-typical-editor"> 
  <title>A typical editor window</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/editor-summary&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The main bulk of the window is taken up with the timeline; this is the
area in which regions and automation are displayed, with time moving
from left to right.  The track controls area gives a set of controls
for each track, for basic operations such as solo, mute and so on.
The (optional) editor mixer is a single mixer strip which handles the
currently-selected track, and is useful for tweaks to the mix without
the need to move to the full mixer window.  At the bottom of the
window is the &lsquo;summary&rsquo;, which displays the whole session in a
reduced-size form.  At the top right is a bar of useful information
about the state of the system.
</para>

<para>
The operation of the editor window is described in more detail in
<xref linkend="ch-editor-window"/>.
</para>

</section>
<section>
<title>The mixer window</title>
<indexterm><primary>mixer</primary></indexterm>

<para>
The other main Ardour window is the <emphasis>Mixer</emphasis>.  A typical mixer
window is shown in <xref linkend="fig-typical-mixer"/>.
</para>

<figure id="fig-typical-mixer"> 
  <title>A typical mixer window</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/mixer-summary&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The main part of the window is taken up with <emphasis>mixer strips</emphasis>, one
for each track or bus in the session, which correspond roughly to the
channel strips on a conventional mixing desk.  This window allows you
to process audio, route signals around and balance your mix.
</para>

<para>
The operation of the mixer window is described in more detail in
<xref linkend="ch-signal-flow-and-the-mixer"/>.
</para>

</section>
</section>
</chapter>




<!-- ====================================================================================
     QUICK START
     ==================================================================================== -->

<chapter>
<title>Quick start</title>

<!-- XXX: links to things later on -->

<para>
This chapter blithely assumes that you just want to use Ardour to make
a basic audio recording from a sound card, and describes how that can
be achieved.  We assume that you have some sound source (such as a
microphone, guitar or whatever) plugged into one of your sound card's
inputs, and a monitoring system (speakers or headphones) connected to
its outputs.
</para>

<section>
<title>Starting Ardour and creating a session</title>

<para>
When Ardour is run for the first time, it starts with the dialogue box
shown in <xref linkend="fig-welcome-to-ardour"/>.  Click <guibutton>Forward</guibutton> to continue.
</para>

<figure id="fig-welcome-to-ardour"> 
  <title>Welcome to Ardour!</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/welcome-to-ardour&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
As it is the first run, Ardour now asks a few basic questions about
how it should be set up.  Its first question is about where to put
sessions by default, as shown in
<xref linkend="fig-default-folder-for-new-sessions"/>.  The initial choice
will be the your home directory; other locations can be selected by
clicking on the button and selecting an alternative directory.
</para>

<figure id="fig-default-folder-for-new-sessions"> 
  <title>Default folder for new sessions</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/default-folder-for-new-sessions&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The next choice governs how Ardour will handle monitoring, as shown in
<xref linkend="fig-monitoring-choices"/>.  For the purposes of this test,
choose &lsquo;Ask Ardour to playback material as it is being recorded', as
this makes things slightly clearer in many cases.
</para>

<figure id="fig-monitoring-choices"> 
  <title>Default folder for new sessions</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/monitoring-choices&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Following this, Ardour asks for a choice with respect to a monitor
section (see <xref linkend="fig-monitor-section"/>).  This is explained in
more detail later; for now, just choose the default &lsquo;use a master bus
directly'.
</para>

<figure id="fig-monitor-section">
  <title>Monitor section</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/monitor-section&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
At this point, if JACK has not already been started, Ardour will try
to do it for you.  In order to do that, it asks about how JACK should
be set up (<xref linkend="fig-audio-midi-setup-device"/>).
</para>

<para>
There are three pages to the Audio / MIDI setup dialogue; the first is
&lsquo;device&rsquo;, which allows selection of the sound card that Ardour will
use, the sampling rate at which it will operate, and the buffer size.
For now, select the interface that you are using for recording and
leave other options as they are.  For more information on the options
here, consult <xref linkend="ch-jack"/>.
</para>

<figure id="fig-audio-midi-setup-device">
  <title>Audio/MIDI setup &mdash; device</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/audio-midi-setup-device&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The final step in creating our session is to give it a name, as in
<xref linkend="fig-new-session"/>.  Enter something like &lsquo;test&rsquo; and click
<guibutton>Open</guibutton>.  At last, the reward should be the editor window
(<xref linkend="fig-editor"/>).  The session is created!
</para>

<figure id="fig-new-session">
  <title>New session</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/new-session&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<figure id="fig-editor">
  <title>And finally: the editor!</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/editor&scs;" scale="85"/>
    </imageobject>
  </mediaobject>
</figure>

</section>
<section><title>Adding a track and connecting it up</title>

<para>
The next step is to add a track to our session so that we have
something to record onto.  Choose <guimenuitem>Add Track or
Bus&hellip;</guimenuitem> from <guimenu>Track</guimenu> at the top of
the editor window.  This will bring up a dialogue box, as shown in
<xref linkend="fig-quickstart-add-track-or-bus"/>.
</para>

<figure id="fig-quickstart-add-track-or-bus">
  <title><guilabel>Add Track or Bus</guilabel> dialogue</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/add-track-or-bus&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
For now, leave the options as they are; this will create a single
monophonic audio track.  This track must now be connected to the sound
card so that it can record incoming audio.
</para>

<para>
Perhaps the easiest way to connect up this new track is to open its
editor mixer strip.  Do this now by pressing
<keycombo>Shift+E</keycombo> or choosing <guimenuitem>Show Editor
Mixer</guimenuitem> from the <guimenu>View</guimenu> menu.  The top of
the mixer strip that appears looks like that in <xref
linkend="fig-top-of-mixer-strip"/>.
</para>

<figure id="fig-top-of-mixer-strip">
  <title>Top part of a mixer strip</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/top-of-mixer-strip&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
At the top of this mixer strip there are three main buttons.  The
first, labelled &lsquo;Audio 1&rsquo; (the name of the track) can be clicked on to
open a menu of options for the track.  The second, marked &lsquo;1&rsquo; is the
input selector, and the third, marked &phgr;, is a button to invert
the track's signal.
</para>

<para>
In order to look at the connections to the input of this track,
left-click on the button marked &lsquo;1&rsquo; to open the input <emphasis>port
matrix</emphasis>, as shown in <xref
linkend="fig-input-port-matrix"/>.
</para>

<figure id="fig-input-port-matrix">
  <title>Input port matrix</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/input-port-matrix&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
The port matrix is the main interface that Ardour offers for
connecting things together.  In our example matrix, the left-hand side
shows a set of ports that generate audio data; these correspond to the
sound card inputs, outputs of Ardour busses and tracks, and other
things that may exist on the system.  Different groups of these ports
can be seen by choosing one of the tabs on the far left-hand side of
the dialogue.
</para>

<para>
At the bottom of the dialogue is the input to our track.
</para>

<para>
In the example matrix, there is a green dot at the intersection of the
&lsquo;L&rsquo; part of &lsquo;in 1+2&rsquo; and the &lsquo;Audio 1
in&rsquo; port.  This means that the input of the &lsquo;Audio
1&rsquo; track hardware input 1.  Change this connection, if
necessary, by clicking on the square which corresponds to the input to
record from.  At this point, the Audio 1 meter should display any
signal that is being sent into the sound card.  If this is not
working, something has gone wrong.
</para>
</section>

<section><title>Recording</title>

<para>
At this point, Ardour is receiving a signal from some external sound
source via the sound card.  It is now possible to make a test
recording.  Click the record-enable buttons (red buttons with a pink
circle) in both the &lsquo;Audio 1&rsquo; track controls and the main transport
controls (shown in <xref linkend="fig-track-controls"/> and
<xref linkend="fig-transport-controls"/>), then click &lsquo;Play&rsquo; to start
the transport.
</para>

<figure id="fig-track-controls">
  <title>Track controls area</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/track-controls&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

<figure id="fig-transport-controls">
  <title>Main transport controls</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/transport-controls&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
Ardour is now recording; the play-head will move, and a red rectangle
will be drawn where the recording is taking place.  Make a noise with
your external sound source!  When you have finished recording, click
the Stop button in the transport controls area.  You should now have a
region containing your recording on the &lsquo;Audio 1&rsquo; track, as in
<xref linkend="fig-recorded-one-region"/>.
</para>

<figure id="fig-recorded-one-region">
  <title>Editor window after recording a region</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="screenshots/recorded-one-region&scs;"/>
    </imageobject>
  </mediaobject>
</figure>

</section>

<section><title>Playing back your recording</title>

<para>
Now we can play back the audio that you have just recorded.  First,
you will need to move the playhead back to a point before your
recorded region.  Perhaps the easiest way to do this is to click
somewhere within the rulers area of the editor window.
</para>

<!-- some picture of where this is, or a back-link to the editor window -->

<para>
Once the playhead is located before your recording, click the &lsquo;Play&rsquo;
button (or press the spacebar on the keyboard) to start playback.  You
should hear your recording through your monitor speakers or
headphones.
</para>

</section>

<section>
<title>Adding another track as an overdub</title>

<para>
Now we can experiment further by adding an overdub to the first
recording.  First, add a new track, as we did before, and connect it
up to the input on your soundcard which your source is connected to.
</para>

<para>
Now, record-enable the new track, move the playhead to before the
previously recorded region, make sure the session is record-enabled
and start the transport (by clicking &lsquo;Play&rsquo; or pressing the spacebar).
You should hear the previously-recorded audio on your monitor system
while the new recording is in progress.  Record something suitable
over the top of your first region.
</para>

<para>
We now have two tracks of recorded data; you might like to add some
more!
</para>

</section>

<section>
<title>Mix-down</title>

<para>
We will now assume that you want to do a mix-down of your magnum opus
into a stereo WAV file.  Such a file could later be converted to an
MP3, or burned to CD, or simply played-back as-is by some other media
player on your computer.  
</para>

<para>
First, we need to mix the tracks that you have recorded so that they
sound as you want them to.  We will cover much more advanced mixing
and processing later, but for now we will just set the relative levels
of the two tracks.  The easiest way to do this is to open the
<emphasis>mixer</emphasis> window, either by selecting
<guimenuitem>Mixer</guimenuitem> from the <guimenu>Window</guimenu>
menu or by pressing <keycombo>Alt+M</keycombo>.  The mixer window is
shown in <xref linkend="fig-mixer-window"/>.
</para>

<figure id="fig-mixer-window"> 
  <title>The mixer window</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/mixer-window&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Here you will see a mixer strip for each track that you have recorded,
and a &lsquo;master&rsquo; strip.  The signals for each track flow from the
recordings on disk, through the appropriate strip, and they are then
mixed together and passed through the master strip.  The bottom half
of each mixer strip contains a <emphasis>fader</emphasis>; this controls the level
of each track.  You can adjust the levels of each of your recordings
by dragging the mixer strip; the green marker indicates 0dBFS (&lsquo;unity
gain&rsquo;), at which the level of the track will be unaltered from the
recording.
</para>

<para>
Play back your recordings from the editor window, and experiment with
the levels in the mixer window until you have a sound that you are
happy with.
</para>

</section>

<section>
<title>Export</title>

<para>
The final step is to export our recording into a stereo WAV file.
Ardour's export options are extensive, but for now we will keep it
simple.  Choose <guimenuitem>Export to Audio Files</guimenuitem> from
the <guimenuitem>Export</guimenuitem> submenu of the
<guimenu>Session</guimenu> menu, and the <guilabel>Export</guilabel>
dialogue will open, as shown in <xref
linkend="fig-export-dialogue"/>.
</para>

<para>
First, we have to specify the format that we will export in.  Fill in
the <guilabel>Label</guilabel> field with some name like &lsquo;WAV for CD', then click
the <guibutton>New</guibutton> button beside the Format entry in the dialogue, and
click on <guibutton>CD</guibutton>, <guibutton>Lossless (linear PCM)</guibutton>, <guibutton>WAV</guibutton> and
<guibutton>44.1kHz</guibutton> entries.  Then click <guibutton>Save</guibutton> to save the export
preset.  Enter some label for the export in the <emphasis>Location</emphasis>
section, then click <guibutton>Export</guibutton>.  Ardour will mix your session
down to a WAV file and save it in the <code>export</code> subdirectory of
your session folder.
</para>
</section>

</chapter>

<!-- ====================================================================================
     THE EDITOR WINDOW
     ==================================================================================== -->

<chapter xml:id="ch-editor-window">
<title>The editor window</title>
<indexterm><primary>editor</primary></indexterm>

<para>
A typical Ardour editor window is shown in <xref linkend="fig-typical-editor2"/>.
</para>

<figure id="fig-typical-editor2">
  <title>A typical editor window</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="diagrams/editor-summary&dia;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
This window is where audio and MIDI material can be viewed, edited and
manipulated.  It offers a view of your session as it progresses in
time, and allows the constituent parts (tracks, regions, playlists and
so on) to be manipulated.  The contents of the main body of the window
represent the session's tracks and busses, the functionality of which
is discussed in Chapter <xref linkend="ch-tracks-and-busses"/>.
</para>

<para>
The remainder of this chapter discusses the other parts of the editor window.
</para>

<section>
<title>The playhead</title>
<indexterm><primary>playhead</primary></indexterm>

<para>
The red vertical line with arrow heads at either end is the called the
&lsquo;playhead&rsquo;.  The playhead position is used in a few different ways,
but the most obvious is that it lies at the point in time at which
Ardour is currently playing back or recording (or would be, were play
or record to be started).  It is also used in some editing operations,
as we will discuss later.
</para>

</section>

<section>
<title>The toolbar</title>
<indexterm><primary>toolbar</primary></indexterm>

<para>
The toolbar is a set of buttons that change the way the mouse and
keyboard interact with the regions on the tracks, in order to perform
different tasks.
</para>

<xref linkend="fig-toolbar-annotated"/> shows the buttons on the toolbar.

<figure id="fig-toolbar-annotated">
  <title>The Ardour toolbar</title>
  <mediaobject>
    <imageobject>
      <imagedata fileref="diagrams/toolbar-annotated&dia;"/>
    </imageobject>
  </mediaobject>
</figure>

<para>
We will examine the broad function of these tools here, and go into
more detail on their operation later.
</para>

<itemizedlist>
<listitem>
<emphasis>Select/move objects</emphasis> (<keycap>o</keycap>) &mdash; used to mark
  regions or MIDI notes as &lsquo;selected&rsquo;, and to move them around (in
  time, or to a different track, or to a different note in the case of
  MIDI).
</listitem>
<listitem>
<emphasis>Smart mode</emphasis> &mdash; this provides a combination of the
  functionality of &lsquo;select/move objects&rsquo; and &lsquo;select/move ranges&rsquo;
  which may be familiar to users of Pro Tools.
</listitem>
<listitem>
<emphasis>Select/move ranges</emphasis> (<keycap>r</keycap>) &mdash; used to mark
  ranges of time and to manipulate them.
</listitem>
<listitem>
<emphasis>Zoom range</emphasis> (<keycap>z</keycap>) &mdash; this provides a mode whereby a time
  range can be dragged with the mouse, and the editor window will zoom
  to show that time range.
</listitem>
<listitem>
<emphasis>Region gain</emphasis> (<keycap>g</keycap>) &mdash; used to edit audio
  gain curves on regions.
</listitem>
<listitem>
<emphasis>Stretch/shrink</emphasis> (<keycap>t</keycap>) &mdash; allows stretching
  or shrinking of regions in time (using time-stretching /
  pitch-shifting algorithms) or MIDI notes.
</listitem>
<listitem>
<emphasis>Listen</emphasis> -- <!-- XXX: TODO -->
</listitem>
<listitem>
<emphasis>Draw/edit MIDI notes</emphasis> &mdash; used to draw new MIDI notes
  into MIDI regions, or change the length of those that are already
  there.
</listitem>
<listitem>
<emphasis>Edit region contents</emphasis> (<keycap>e</keycap>) &mdash; this is a
  kind of &lsquo;modifier&rsquo; for the other tools.  When selected, it means
  that the other tools will operate on region contents rather
  than the regions themselves.  For example, the select/move tool will
  select and move MIDI notes rather than the regions that the notes
  are in.
</listitem>
</itemizedlist>

</section>

<section>
<title>Rulers</title>

The rulers section of the editor gives the option of several views;
some time indications, in different units, details of tempo and meter
(time signature) changes, and a display of various types of marker.

Right-clicking over the marker area offers a menu from which the
displayed rulers can be chosen.

<section>
<title>Time displays</title>

The time rulers that can be displayed are:
<itemizedlist>
<listitem>
<emphasis>Min:Sec</emphasis> &mdash; time in hours:minutes:seconds:millseconds.
</listitem>
<listitem>
<emphasis>Timecode</emphasis> &mdash; time in hours:minutes:seconds:frames.
</listitem>
<listitem>
<emphasis>Samples</emphasis> &mdash; time in audio samples.
</listitem>
<listitem>
<emphasis>Bars:Beats</emphasis> &mdash; time in bars and beats.
</listitem>
</itemizedlist>

</section>

<section>
<title>Meter and tempo</title>

Ardour provides support for considering a piece of music as having
tempo and meter.  This is optional in the sense that you can happily
ignore tempo and meter settings if they are not relevant to your
recording situation.

Use of tempo has two main effects; firstly, Ardour can provide a
metronome &lsquo;click&rsquo; which can be used as reference to record to.
Secondly, tempo will affect the speed at which MIDI data is played
back, so you can change how your records will sound by changing the
tempo.

Meter (time signature) also affects the metronome click, as the click
will emphasise the sound of the first beat of the bar.  It has no
effect on the <emphasis>playback</emphasis> of MIDI, but adjusting time signature to
match the music may make things more intuitive to work with.

Both tempo and meter affect the grid that is displayed (and,
optionally, snapped to) which shows bars and beats.  The grid will
adjust itself to zoom level, so the finer details of the session may
not be visible if you are zoomed too far out.
</section>

<section id="sec-markers">
<title>Markers</title>

<para>
Ardour supports a variety of markers for various purposes.  Markers
can either be a single point in time or a range of time.
</para>

<para>
The basic marker types for general purpose use are <emphasis>location
markers</emphasis> and <emphasis>range markers</emphasis>.  Location markers are
a point in time, and range markers represent, as one might expect, a
time range.
</para>

<para>
There are some other special marker types.  CD markers are intended to
indicate track marks for CD productions.  If a session has CD markers
at the start of each track, Ardour can generate a table-of-contents
for use with audio exports to allow them to be burnt to CD correctly.
</para>

<para>
Two special range markers are the &lsquo;loop&rsquo; and &lsquo;punch&rsquo; ranges.  The loop
range can be played back in a loop when the <emphasis>play loop
range</emphasis> button is clicked.  The punch range will be used with
punch-in recording.
</para>

</section>
</section>

<section>
<title>Clocks</title>

<para>
This area contains two clocks, the primary and secondary.  They both
show the location of the playhead, but can be set to different time
representations.  By default, for example, the primary clock shows
position as a time-code, and the secondary shows bars, beats and
ticks.
</para>

<para>
Right-clicking on a clock pops up a menu from which you can choose the
time representation from one of the following:
</para>

<itemizedlist>
<listitem>
<emphasis>Timecode</emphasis> &mdash; shows time as
  hours:minutes:seconds:frames.  The number of frames per second is
  set by the session property &lsquo;timecode frames-per-second&rsquo; (see
  <xref linkend="sec-session-properties-timecode"/>).
</listitem>
<listitem>
<emphasis>Bars:Beats</emphasis> &mdash; shows time as
  bars|beats|text|ticks (there are 1920 ticks per beat).
</listitem>
<listitem>
<emphasis>Minutes:Seconds</emphasis> &mdash; shows time as
  hours:minutes:seconds:milliseconds.
</listitem>
<listitem>
<emphasis>Samples</emphasis> &mdash; shows time as samples (according to the
  sampling rate that JACK is using).
</listitem>
</itemizedlist>

<para>
In addition to the time, the clock shows some other information.
</para>

<para>
When set to &lsquo;timecode&rsquo;, the clock also shows the timecode reference
source; this defaults to &lsquo;INT&rsquo; for internal, but can also be &lsquo;JACK&rsquo; if
JACK is the timecode reference, &lsquo;MTC&rsquo; if Ardour is syncing to MIDI
time-code or &lsquo;M-Clock&rsquo; if Ardour is synced to MIDI clock.  To the
right of the timecode reference is the number of frames per second
(suffixed by &lsquo;D&rsquo;) if drop-frame is being used.
</para>

<para>
In &lsquo;Bars:Beats&rsquo; mode, the area underneath the time shows the tempo (in
beats per minute) and time signature that are currently in effect.
</para>

</section>

<section>
<title>Times area</title>

<para>
The times area of the editor window shows a few useful bits of
information about any current selection and punch in/out range.  The
&lsquo;selection&rsquo; area shows the start, end and length of anything that is
currently selected (which may be a set of regions, a time range, or
whatever).  The &lsquo;punch&rsquo; area shows the punch range, and also whether
punch in and punch out are enabled; clicking &lsquo;In&rsquo; or &lsquo;Out&rsquo; will enable
punch in and out respectively, and the buttons will turn red in colour
to indicate that the corresponding punch is switched on.
</para>

</section>

<section xml:id="sec-edit-point-selector">
<title>Edit point selector</title>
<indexterm><primary>edit point</primary></indexterm>

<para>
The &lsquo;edit point&rsquo; is a point in time within the session that is used
for a variety of different editing operations.  The edit point
selector is used to choose where the edit point should be; it can be
either at the playhead, at the selected marker or at the
mouse pointer position.
</para>

</section>

<section>
<title>Zoom controls</title>
<indexterm><primary>zoom</primary></indexterm>

The zoom controls are shown in <xref linkend="fig-zoom-controls"/>.

<figure id="fig-zoom-controls"> 
  <title>The zoom controls</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/zoom-controls&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The zoom in and out controls zoom the editor window in and out in
terms of time; the &lsquo;zoom to session&rsquo; button zooms the editor window so
that the whole session is visible.  The &lsquo;zoom focus button&rsquo; selects
a reference point to decide which part of the session the editor window
should display after the zoom.  These reference points are as follows:

<itemizedlist>
<listitem>
<emphasis>Left</emphasis> &mdash; the left-hand side of the editor
window remains at the same point in time.
</listitem>
<listitem>
<emphasis>Right</emphasis> &mdash; the right-hand side of the editor
window remains at the same point in time.
</listitem>
<listitem>
<emphasis>Center</emphasis> &mdash; the centre of the editor window
remains at the same point in time.
</listitem>
<listitem>
<emphasis>Playhead</emphasis> &mdash; the playhead will be kept in the
centre of the editor window (where possible).
</listitem>
<listitem>
<emphasis>Mouse</emphasis> &mdash; the point of the session that the
mouse pointer is over will be kept at the same point in the editor
window.
</listitem>
<listitem>
<emphasis>Edit point</emphasis> &mdash; the current edit point will be
used as a reference.
</listitem>
</itemizedlist>
</para>

</section>

<section>
<title>Grid controls</title>
<indexterm><primary>grid</primary></indexterm>

<para>
Ardour has an optional &lsquo;grid&rsquo; which can be used to align things
precisely in time.  The grid can either be disabled (by choosing &lsquo;No
Grid&rsquo; from the drop-down box), fully enabled (&lsquo;Grid&rsquo;) or &lsquo;Magnetic&rsquo;.
When the grid is fully enabled, any object that is moved (regions,
MIDI notes or automation points, for example) will be forcibly snapped
to the grid.  In &lsquo;magnetic&rsquo; mode, it is possible to move things off
the grid, but when they get close to a grid intersection they will be
snapped.
</para>

<para>
Next to the grid on/off drop-down box is a selector for the interval
to snap to.  There are a large variety of options here, most of which
are self explanatory.  &lsquo;Region starts/ends/syncs/bounds&rsquo; snaps to
various parts of existing regions, which can be useful when alignment
needs to be relative to existing material rather than some arbitrary
grid.
</para>

</section>

<section>
<title>Nudge controls</title>
<indexterm><primary>nudge</primary></indexterm>

<para>
The nudge controls allow objects to be &lsquo;nudged&rsquo;, or moved by a fixed
amount backward or forward.  The left and right buttons move currently
selected things either backward or forward in time, and the small
clock to the left of these buttons sets the amount of time to nudge
by.  As with all other clocks, you can right-click on the clock to
choose the time representation you want to use.
</para>

</section>

<section>
<title>The editor lists</title>

<para>
At the right of the editor is an optional area which provides one of a
range of useful lists of parts of your session.  The list can be
hidden or shown using the <guimenuitem>Show Editor List</guimenuitem>
option from the <guimenu>View</guimenu> menu.  The very right-hand
side of the list gives a selection of tabs which are used to choose
the list to view.  The left-hand border of the list can be dragged to
vary the width of the list.
</para>

<section xml:id="sec-region-list">
<title>Region list</title>
<indexterm><primary>region list</primary></indexterm>

<para>
The region list shows all the regions in the session.  The left-hand
column gives the region name, and there are a range of times given for
information.  At the right of the list are four columns of flags that can be altered:
</para>

<itemizedlist>
<listitem>
<emphasis>L</emphasis> &mdash; whether the region position is locked, so that it
  cannot be moved.
</listitem>
<listitem>
<emphasis>G</emphasis> &mdash; whether the region's position is &lsquo;glued&rsquo; to bars
  and beats.  If so, the region will stay at the same position in bars
  and beats even if the tempo and/or time signature change.
</listitem>
<listitem>
<emphasis>M</emphasis> &mdash; whether the region is muted, so that it will not be heard.
</listitem>
<listitem>
<emphasis>O</emphasis> &mdash; whether the region is opaque; opaque regions
  &lsquo;block&rsquo; regions below them from being heard, whereas &lsquo;transparent&rsquo;
  regions have their contents mixed with whatever is underneath.
</listitem>
</itemizedlist>

<para>
Hovering the mouse pointer over a column heading shows a tool-tip
which can be handy to remember what the columns are for.
</para>

<para>
A handy feature of the region list is that its regions can be dragged
and dropped into a suitable track in the session.
</para>

</section>

<section>
<title>Tracks &amp; Busses</title>

<para>
This lists the tracks and busses that are present in the session.  The
list order reflects the order in the editor, and you can drag-and-drop
track or bus names in the editor list to re-order them in the editor.
The columns in the list can all be clicked to alter the track/bus
state, and they represent the following:
</para>

<itemizedlist>
<listitem> <emphasis>V</emphasis> &mdash; whether the track or bus is visible; they can be
  hidden, in which case they will still play, but just not be visible
  in the editor; this can be useful for keeping the display uncluttered.
</listitem><listitem> <emphasis>A</emphasis> &mdash; whether the track or bus is active; unactive
  tracks will not play, and will not consume any CPU.
</listitem><listitem> <emphasis>I</emphasis> &mdash; for MIDI tracks, whether the MIDI input is
  enabled; this dictates whether MIDI data from the track's inputs
  ports will be passed through the track.
</listitem><listitem> <emphasis>R</emphasis> &mdash; whether the track is record-enabled.
</listitem><listitem> <emphasis>M</emphasis> &mdash; whether the track is muted.
</listitem><listitem> <emphasis>S</emphasis> &mdash; track solo state.
</listitem><listitem> <emphasis>SI</emphasis> &mdash; track solo-isolated state.
</listitem><listitem> <emphasis>SS</emphasis> &mdash; solo safe state.
</listitem>
</itemizedlist>

<para>
As with the region list, hovering the mouse pointer over a column
heading shows a tool-tip which can be handy to remember what the
columns are for.
</para>

</section>
<section><title>Snapshots</title>
<indexterm><primary>snapshot</primary></indexterm>

<para>
This list gives the snapshots that exist of this session.  Clicking on
a snapshot name will load that snapshot.
</para>

</section>
<section><title>Track &amp; Bus Groups</title>

<para>
This shows the track/bus groups that exist in the session.  These
groups allow related tracks to share various properties (such as mute
or record enable state).  For full details, see
<xref linkend="sec-track-and-bus-groups"/>.
</para>

<para>
The columns in this list are as follows:
</para>

<itemizedlist>
<listitem>
<emphasis>Col</emphasis> &mdash; the colour that the group uses for its tab in the editor.
</listitem>
<listitem>
<emphasis>Name</emphasis> &mdash; the group name.
</listitem>
<listitem>
<emphasis>V</emphasis> &mdash; whether the tracks and busses in the group are visible.
</listitem>
<listitem>
<emphasis>On</emphasis> &mdash; whether the group is enabled.
</listitem>
<listitem>
<emphasis>G</emphasis> &mdash; ticked if the constituents of the group are sharing gain settings.
</listitem>
<listitem>
<emphasis>Rel</emphasis> &mdash; ticked if shared gains are relative.
</listitem>
<listitem>
<emphasis>M</emphasis> &mdash; ticked if the constituents share mute status.
</listitem>
<listitem>
<emphasis>S</emphasis> &mdash; ticked if the constituents share solo status.
</listitem>
<listitem>
<emphasis>Rec</emphasis> &mdash; ticked if the constituents share record-enable status.
</listitem>
<listitem>
<emphasis>Mon</emphasis> &mdash; whether the constituents share monitor settings.
</listitem>
<listitem>
<emphasis>Sel</emphasis> &mdash; whether the constituents are selected together.
</listitem>
<listitem>
<emphasis>E</emphasis> &mdash; whether edits to the constituents are performed to all others.
</listitem>
<listitem>
<emphasis>A</emphasis> &mdash; whether the constituents share active status.
</listitem>
</itemizedlist>

</section>

<section>
<title>Ranges &amp; Marks</title>

This lists the ranges and markers that exist in the session, and
allows them to be edited.  First, there is the current loop and punch
range; there are three clocks, being the start of the range, the end
of the range and the length of the range.  The start and end points
have a &lsquo;Use PH&rsquo; button beside them, which you can click to set the
corresponding position using the current position of the playhead.

Following this is a list of the session's markers, and finally there
is a list of the range markers.

At the bottom of the list are buttons to add new markers or ranges.

The <guibutton>-</guibutton> button beside each marker and range
allows that particular mark to be removed.

</section>
</section>

<section>
<title>Other buttons</title>

The editor window contains a few other buttons, which are described here.

<section>
<title>Solo</title>

This button flashes red if any tracks are soloed, and you can click it
to turn off all solos.

</section>

<section>
<title>Feedback</title>
<indexterm><primary>feedback</primary></indexterm>

It is possible to connect things up so that there are feedback loops;
a simple example might be connecting the output of a track to its
input, but obviously there are much more convoluted arrangements
possible.  Ardour detects any feedback that exists, and will keep its
signal processing pathways in the state they were in just before the
feedback was introduced.  If Ardour is doing this, it flashes the
feedback button to let you know that the routing in effect may not be
what the user interface is showing.  You should remove the feedback
path, upon which this light will stop flashing.

<!-- XXX
Metronome
Audition}
Internal
Auto Play
Auto Return
-->

</section>
</section>

<section>
<title>The transport controls</title>

Ardour uses the term &lsquo;transport&rsquo; in a sense that might be similar to
those who have used tape machines.  The transport is said to be
&lsquo;moving&rsquo; (or &lsquo;rolling&rsquo;, as with tape) when Ardour is playing back or
recording, and &lsquo;stopped&rsquo; when it is not.  The transport can be
controlled using the buttons shown in
<xref linkend="fig-transport-controls2"/>.

<figure id="fig-transport-controls2"> 
  <title>Main transport controls</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/transport-controls&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

From left to right, these controls are:
<itemizedlist>
<listitem>
<imagedata fileref="screenshots/midi-panic&scs;"/> &mdash;
  <emphasis>MIDI panic</emphasis> &mdash; click this to send note-offs and reset
  controller messages on all MIDI channels.  This is useful if, for
  example, a MIDI synthesizer has a stuck note and you want to silence
  it.
</listitem>
<listitem>
<imagedata fileref="screenshots/go-to-start&scs;"/> &mdash;
  <emphasis>Start of session</emphasis> &mdash; moves the playhead to the session
  start marker.
</listitem>
<listitem>
<imagedata fileref="screenshots/go-to-end&scs;"/> &mdash; <emphasis>End
of session</emphasis> &mdash; moves the playhead to the session end
marker.
</listitem>
<listitem>
<imagedata fileref="screenshots/loop&scs;"/> &mdash; <emphasis>Play
loop</emphasis> &mdash; this starts playback in looped mode, so that
the current loop range will be played repeatedly.
</listitem>
<listitem>
<imagedata fileref="screenshots/play-range&scs;"/> &mdash;
<emphasis>Play range or selection</emphasis> &mdash; if there is a
selected time range, it will be played back.
</listitem>
<listitem>
<imagedata fileref="screenshots/play&scs;"/> &mdash;
<emphasis>Play</emphasis> &mdash; this starts playback of the session
from wherever the playhead currently is (in other words, it sets the
transport &lsquo;rolling&rsquo;, or moving)
</listitem>
<listitem> 
<imagedata fileref="screenshots/stop&scs;"/> &mdash;
<emphasis>Stop</emphasis> &mdash; this stops playback or record.
</listitem>
<listitem>
<imagedata fileref="screenshots/record&scs;"/> &mdash;
<emphasis>Record</emphasis> &mdash; if this is clicked so that it
flashes red, Ardour will record onto record-enabled tracks when the
transport is moving.
</listitem>
</itemizedlist>

</section>

<section xml:id="sec-summary">
<title>The summary</title>
<indexterm><primary>summary</primary></indexterm>

<para>
The summary area of the editor window gives an overview of your entire
session.  No matter how long the session is, or how many tracks it
has, the summary will arrange itself so that the entire session is
drawn within it.  Inside the summary tracks are represented as
light-grey bars, regions as coloured bars, the playhead as a vertical
red line and the session start and end markers as vertical yellow
lines.  On top of the summary is drawn a light-grey translucent box
(the &lsquo;view box&rsquo;) which indicates the part of the session that is
currently visible in the main part of the editor window.
</para>

<para>
The summary is intended for two main purposes: firstly, to get an idea
of the whole session at a glance, and secondly to navigate around it
easily.  You can use the summary to do the following things:
</para>

<itemizedlist>
<listitem>Dragging the view box around will move the view of the session
  in the main editor window.
</listitem>
<listitem>Resizing the view box (by clicking and dragging on its edges)
  will zoom into or out of the session.
</listitem>
<listitem>Clicking with <keycap>&modtwo;</keycap> held down will move
the playhead to the click position.
</listitem>
<listitem>Clicking with <keycap>&modtertiary;</keycap> held down will
centre the editor's view at the click position.
</listitem>
<listitem>Moving the mouse's scroll-wheel will scroll the editor's view.
</listitem>
<listitem>Moving the mouse's scroll-wheel with <keycap>&modone;</keycap> held down will
  zoom the editor's view in or out.
</listitem>
<listitem>Moving the mouse's scroll-wheel with <keycap>&modtwo;</keycap> held down will
  scroll the editor's view left or right.
</listitem>
</itemizedlist>

The left, right, up and down buttons to either side of the summary
allow the editor window to be scrolled in each direction.

<section>
<title>The status bar</title>

This contains the following things:
<itemizedlist>
<listitem>
<emphasis>File</emphasis> &mdash; the type of file that Ardour is using to record audio;
this can be change from the <guilabel>Media</guilabel> tab of the <guilabel>Session
Properties dialogue</guilabel> (see <xref linkend="sec-session-properties-media"/>).
</listitem>
<listitem>
<emphasis>JACK</emphasis> &mdash; the sampling rate that JACK (and therefore Ardour) is
 using, and the duration of one JACK period.
</listitem>
<listitem>
 <emphasis>Buffers</emphasis> &mdash; how full the &lsquo;playback buffers&rsquo; are (prefixed &lsquo;p&rsquo;),
  and how empty the &lsquo;capture buffers&rsquo; (prefixed &lsquo;c&rsquo;).  The playback
  buffers are areas of memory that Ardour uses to store audio and MIDI
  data while it is being passed from the disk to the audio outputs;
  Ardour tries to keep them full (so that there is always data
  available for playback), but if you have a lot of tracks and (or)
  slow disks, Ardour may not be able to keep up.  The closer the
  playback buffer number is to 100%, the better.  Similarly, as data
  is being captured for record, Ardour tries to write it to disk; if
  it cannot write the data quickly enough, the record buffers will
  fill and problems will occur.
</listitem>
<listitem>
<indexterm><primary>DSP</primary></indexterm><emphasis>DSP</emphasis>
&mdash; an estimate of the amount of time that Ardour is spending
doing digital signal processing (DSP) of your session.  If this gets
near 100% it indicates that your system is being overloaded, and you
may get glitches or &lsquo;pops&rsquo; in your audio.  First steps to fixing this
are:
</listitem>

<itemizedlist>
<listitem>
Reduce the number of plugins you are using (especially complicated ones like reverbs).
</listitem>
<listitem>
&lsquo;Freeze&rsquo; some tracks.
</listitem>
<listitem>
Increase JACK's buffer size.
</listitem>
<listitem>
Get a faster computer!
</listitem>
</itemizedlist>

<sidebar>
<para>
Every time JACK calls Ardour, to give it audio from inputs and take
away audio from outputs, Ardour has until the next JACK call to do its
processing.  The DSP load is the percentage of this available time
that Ardour is taking up.  More than 100% means that Ardour will not
have performed one lot of processing before JACK asks it to do more,
so the system is critically overloaded.  As suggested above, one can
increase Ardour's chances of getting everything finished by increasing
the period between JACK's calls (by increasing the JACK buffer size),
or by reducing the amount of time Ardour requires to do its work (by
reducing plugin count, or using faster hardware).
</para>

<para>
Note that DSP load will probably not vary predictably with CPU speed.
Many other things are involved in the timing of the sound-card / JACK
/ Ardour interaction; including the real-time performance of your
system and kernel, the details of your hardware, and in some cases
blind (good or bad) luck.
</para>
</sidebar>

<listitem>
<emphasis>Disk</emphasis> &mdash; the amount of time for which you can record (on the
  tracks that are currently record-enabled) given the amount of disk
  space you have available.  If no tracks are record-enabled, the time
  remaining is computed assuming that you are recording one track.
</listitem>
<listitem>
And finally, the time (using the 24-hour clock), just in case you have somewhere to be.
</listitem>
</itemizedlist>

<para>
The various parts of the status bar can be shown or hidden by
right-clicking and choosing the elements that you want to see.  This
can be useful for reducing the editor window's width for use on small
screens.
</para>

</section>
</section>
</chapter>

<!-- ====================================================================================
     TRACKS AND BUSSES
     ==================================================================================== -->

<chapter xml:id="ch-tracks-and-busses">
<title>Tracks and busses</title>

<para>
The basic building blocks of Ardour's sessions are <emphasis>tracks</emphasis>
and <emphasis>busses</emphasis>.
</para>

<para>
Both are built on the same foundation; a bus functionality is a
subset of a track's.  Both can pass audio and MIDI data, apply
processing and perform various signal routing operations.  The
difference with a track is that can record and play back data.
</para>

<section>
<title>Track and bus basics</title>

<section>
<title>Types</title>

<para>
An Ardour track can be either &lsquo;audio&rsquo; or &lsquo;MIDI&rsquo;.  The only real
difference between the two is the type of data that the track will
record and play back.  Either type of track can
<emphasis>pass</emphasis> either type of data.  Hence, for example,
one might have a MIDI track that contains an instrument plugin; such a
track would contain MIDI data, but would produce audio, since the
instrument would turn the one into the other.
</para>

<para>
In Ardour 3 busses are only used for audio.
</para>

</section>

<section>
<title>Adding and removing tracks</title>

<para>
A track or bus can be added to a session in various ways:
</para>

<itemizedlist>
<listitem> Choose <guimenuitem>Add Track or Bus&hellip;</guimenuitem> from the <guimenu>Track</guimenu> menu.
</listitem><listitem> Right-click in an empty part of the track controls area.
</listitem><listitem> Click the + button underneath the list of tracks in the mixer.
</listitem>
</itemizedlist>

<para>
Any of these actions will open the <emphasis>Add Track or Bus</emphasis> dialogue,
as shown in <xref linkend="fig-add-track-or-bus"/>.
</para>

<figure id="fig-add-track-or-bus"> 
  <title>Add Track or Bus dialogue</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/add-track-or-bus&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
From here, you can select firstly the number of tracks or busses to
add, and the type; audio track, MIDI track or bus.  There are also
some options, which vary depending on the type of thing you are
creating.
</para>

These options are:

<itemizedlist>
<listitem> Configuration (for audio tracks and busses) &mdash; this is the
  number of input and outputs the track is set up with.  You can
  always change these counts later.
</listitem>
<listitem>
Track mode (for audio tracks) &mdash; this can be &lsquo;normal&rsquo;,
&lsquo;non-layered&rsquo; or &lsquo;tape&rsquo;.
<!--  I have no idea what non-layered nor tape modes do -->
</listitem>
<listitem>
 Group &mdash; tracks and busses can be put into groups so that a
  selected range of operations are applied to all members of a group
  at the same time (selecting record enable, or editing, for example).
  This option allows you to specify an existing group to add the new
  track(s) or bus(ses) to, or to create a new group to put the new
  things in.
</listitem>
<listitem>
 Instrument (for MIDI tracks) &mdash; this is a short-cut to allow you
 to create a MIDI track with an instrument plugin already added to it.
 You can achieve the same effect by creating a MIDI track with no
 plugins and adding it yourself; this option just makes things
 slightly quicker.
</listitem>
</itemizedlist>

<para>
Adding tracks will add them to both the editor and mixer windows; the
editor window shows the timeline, with any recorded data, and the
mixer shows just the processing elements of the track (its plugins,
fader and so on).
</para>

<para>
Tracks and busses can be removed by selecting them, right-clicking and
choosing &lsquo;Remove&rsquo; from the menu.  A warning dialogue will pop up, as
<emphasis>track removal cannot be undone</emphasis>; use this option with care!
</para>

</section>
</section>

<section xml:id="sec-track-and-bus-groups">
<title>Track and bus groups</title>
<indexterm><primary>group</primary></indexterm>

<para>
Tracks and busses can be put into <emphasis>groups</emphasis>. The members of a
group can be set to share various settings, which can be useful for
managing tracks which are closely related to each other.  Examples
might include tracks that contain multiple-microphone recordings of a
single source (an acoustic guitar, perhaps, or a drum-kit).
</para>

<para>
You can put tracks and busses into groups in various ways.  In the
editor window, a track's controls might look like those in
<xref linkend="fig-track-in-group"/>.
</para>

<figure id="fig-track-in-group"> 
  <title>The header of a track in a group</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/track-in-group&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The green tab to the left of the track header indicates that this
track is in a group called &lsquo;Fred&rsquo;.  These tabs can be dragged in the
editor window to add to or remove tracks from groups.  Alternatively,
clicking the &lsquo;g&rsquo; button opens a menu which gives a list of the
available groups; selecting one of these groups will add the track or
bus to that group.  This menu also allows a new group to be created.
</para>

<para>
The properties of a group can be edited by right-clicking on its tab
and choosing <guimenuitem>Edit Group&hellip;</guimenuitem>.  This will
open the track/bus group dialogue, which is also used when creating
new groups, as shown in <xref
linkend="fig-route-group-dialogue"/>.
</para>

<figure id="fig-route-group-dialogue"> 
  <title>The track/bus group dialogue</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshot/route-group-dialogue&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
&lsquo;Active&rsquo; means that the group is being obeyed, so that the sharing of
properties is applied to its members.  The colour can be changed, and
affects the colour of the group's tab in the editor and mixer windows.
</para>

<para>
Following these options are a list of the things that the members of
the group can share.  &lsquo;Gain&rsquo; means that the track faders will be
synced to always have the same value; &lsquo;Relative&rsquo; means that the gain
changes are applied relative to each member's current value.  If, for
example, there are two tracks in a group with relative gain sharing,
and their faders are set to -3dB and -1dB, a change of the first
track to a gain of -6dB will result in the second track having a
gain of -4dB (so that the difference in gains is the same).
</para>

<para>
&lsquo;Muting&rsquo;, &lsquo;soloing&rsquo;, &lsquo;record enable&rsquo;, &lsquo;route active state&rsquo;, &lsquo;colour&rsquo;
and &lsquo;monitoring&rsquo; are all straightforward; they simply mean that all
member tracks or busses will share the same settings in these
respects.
</para>

<para>
&lsquo;Selection&rsquo; means that if a region is selected or deselected on one
constituent track, corresponding regions on other member tracks will
be similarly selected.  Corresponding regions are those that are at
the same position and have the same length.  Similarly, &lsquo;Editing&rsquo;
means that edits applied to one track will be applied at the same
place on other tracks in the group.  These options are particularly
useful for multi-microphone recordings, where you always want to apply
the same edits to each track.
</para>

<para>
Right-clicking on the group tab offers a further menu of group-related
actions.  <guimenuitem>Create a New Group</guimenuitem> does as its name suggests, and
there is also an option to create a new group and automatically put
particular tracks into it.  <emphasis>Collect Group</emphasis> moves all the member
tracks so that they are together in the editor window, and
<guimenuitem>Remove Group</guimenuitem> removes the group (and only the group, not its
members).
</para>

<para>
<guimenuitem>Add New Subgroup Bus</guimenuitem> creates a bus (giving
it the name of the group) and connects the output of each member to
the new bus.  In a similar way, <guimenuitem>Add New Aux
Bus</guimenuitem> adds a bus and gives each member a send to that bus.
There are two options for this, specifying whether the sends should be
placed pre- or post-fader.
</para>

<para>
Finally, <guimenuitem>Fit to Window</guimenuitem> will zoom the member
tracks so that they fill the editor window.
</para>

</section>

<section>
<title>Tracks and busses in the editor window</title>

<para>
When a track or bus is added to a session it is given a representation
in both the editor and the mixer windows.  Broadly speaking, the
editor window shows the track's timeline, and the mixer window its
signal processing.
</para>

<para>
On the left of a track or bus in the editor is the controls area.  The
contents of this area are different for audio tracks, MIDI tracks and busses.
</para>

</section>
<section>
<title>Busses</title>

<para>
A typical control area for a bus is shown in <xref
linkend="fig-typical-bus-controls"/>.
</para>

<figure id="fig-typical-bus-controls"> 
  <title>Controls for a typical bus</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshot/typical-bus-controls&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
At the top-left of the controls is the name of the bus.  This can be
edited directly to whatever is suitable, although the name must be
unique within the session.  Underneath the name is a copy of the bus'
main level fader.  The control buttons to the right-hand side are:
</para>

<itemizedlist>
<listitem>
<emphasis>&lsquo;m&rsquo;</emphasis> &mdash; mute &mdash; left-click to mute the
bus.  Right-click to display a menu which dictates what particular
parts of the bus should be muted. <!-- detail of muting options -->
</listitem>
<listitem>
<emphasis>&lsquo;s&rsquo;</emphasis> &mdash; solo &mdash; solo the bus.  The
behaviour of the solo system is described in detail in <xref
linkend="sec-mute-and-solo"/>.
</listitem>
<listitem>
<emphasis>&lsquo;a&rsquo;</emphasis> &mdash; automation &mdash; click to open a
menu related to automation for the bus.  Automation is covered in
<xref linkend="ch-automation"/>.
</listitem>
<listitem>
<emphasis>&lsquo;g&rsquo;</emphasis> &mdash; group &mdash; click to open a menu
related to the bus group, as discussed in <xref
linkend="sec-track-and-bus-groups"/> above.
</listitem>
</itemizedlist>

</section>
<section><title>Audio tracks</title>

<para>
A typical control area for an audio track is shown in <xref linkend="fig-typical-audio-track-controls"/>.
</para>

<figure id="fig-typical-audio-track-controls"> 
  <title>Controls for a typical audio track</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/typical-audio-track-controls&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
An audio track has the same controls as a bus, with the addition of
two extras.  The red button with the pink circle is the track's
<emphasis>record enable</emphasis>.  When this is clicked it will gain a bright red
outline, and the track will then be recorded onto when the main
session record enable is turned on with the transport rolling.
</para>

<para>
The &lsquo;p&rsquo; button below the record enable will open a playlist menu when
clicked.  The menu offers various operations related to the track's
playlist.  This, as you will recall, is simply a list of the
regions that the track should play.  Playlists may be swapped on a
given track, and may be used by more than one track at the same time.
They are often useful to keep different takes, for example, or to
allow one set of regions to be played off two tracks with different
processing.
</para>

<!-- playlist menu details -->

</section>
<section><title>MIDI tracks</title>

<para>
A typical control area for a MIDI track is shown in <xref linkend="fig-typical-midi-track-controls"/>.
</para>

<figure id="fig-typical-midi-track-controls"> 
  <title>Typical MIDI track controls</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/typical-midi-track-controls&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The MIDI track example is shown at a greater height than the other
examples, as with MIDI tracks there are some control elements which
only appear when there is sufficient vertical space to fit them in.
</para>

<para>
A MIDI track has the same basic controls as an audio track, with the
addition of two extra elements.  The set of buttons below the main
track controls controls the MIDI channels that should be visible in
the editor.  A MIDI track's data may span any number of the 16
available MIDI channels, and sometimes it is useful to view only a
subset of those channels; different instruments may, for example, be
put on different MIDI channels.  Clicking on a channel number toggles
its visibility.
</para>

<!-- What does Force do -->

<para>
To the right of the MIDI track controls is a representation of a piano
keyboard called the &lsquo;scroomer&rsquo;.  This performs a couple of functions.
Firstly, the scroll-bar controls the range of pitches that are visible
on the track.  Dragging the scroll-bar body up and down scrolls up and
down through the visible pitches, and dragging the scroll-bar
&lsquo;handles&rsquo; zooms in and out, so that more or fewer pitches are visible.
The piano keyboard gives a reference for the pitches that the track is
displaying.  In addition, clicking on the notes will generate the
corresponding MIDI note in the track.
</para>

</section>
</chapter>



<!-- ====================================================================================
     SIGNAL FLOW AND THE MIXER
     ==================================================================================== -->

<chapter xml:id="ch-signal-flow-and-the-mixer">
<title>Signal flow and the mixer</title>

<!-- Audio vs. MIDI -->

<para>
The second of Ardour's two main windows is the <emphasis>mixer</emphasis>.  A
typical mixer window is shown in <xref linkend="fig-mixer-summary"/>.
</para>

<figure id="fig-mixer-summary">
  <title>A typical mixer window</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/mixer-summary&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The mixer is roughly Ardour's equivalent of a physical mixing console
with some outboard processing.  It provides an overview of the signals
present in the session, and allows them to be mixed and processed.
</para>

<para>
At the left hand side of the window there are two useful lists; at the
top, a list of the session's tracks and busses, and at the bottom a
list of the track and bus groups.  Each track, bus and group has a
corresponding &lsquo;show&rsquo; tick-box which controls whether the corresponding
item is visible in the mixer.  These tick-boxes do not affect
visibility in the editor window.
</para>

<para>
The main body of the mixer window is taken up with mixer strips.  Each
track and bus has one of these, and there is an extra one for the
master bus.  An annotated single mixer strip is shown in
<xref linkend="fig-mixer-strip-summary"/>.
</para>

<figure id="fig-mixer-strip-summary">
  <title>A typical mixer strip</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/mixer-strip-summary&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<section>
<title>Signal flow in the strip</title>

<para>
This mixer strip represents the signal flow through a single track or
bus.  The input to the strip comes either from a set of JACK ports or
from the regions in a track's playlist.  The signal then flows through
a set of <emphasis>processors</emphasis>, which may include <emphasis>plugins</emphasis> (which
process the signal in some way) and a <emphasis>fader</emphasis> to control level.
The signal is then <emphasis>panned</emphasis> to its output ports.
</para>

<para>
The basic signal flow for a track is shown in
<xref linkend="fig-basic-track-signal-flow"/>.
</para>

<figure id="fig-basic-track-signal-flow">
  <title>Basic track signal flow</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/basic-track-signal-flow&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<section>
<title>Input</title>

<para>
At the top of the figure we have two possibilities for input data; it
can either come &lsquo;live&rsquo; from some JACK input ports (so that
it could have come from, for example, a sound card, or perhaps another
application) or it can come from disk.  If the track is record
enabled, the data from the JACK inputs is stored as-is on disk (with
no processing) when we are recording.  The signal that goes into the
actual strip can be chosen as either the live input or the disk;
Ardour can usually make this decision for you depending on what is
going on; alternatively, you can specify it manually.  This signal
heads into the strip's processors before being panned and passed to
the JACK outputs.
</para>

<para>
A bus&rsquo; signal flow is similar, except that there is no disk storage
involved, so there is no input switching; the signal always comes from
its JACK input ports.
</para>

<para>
Let us examine the mixer strip with reference to this signal flow.
Towards the top of the strip you will see the <emphasis>input connections</emphasis>
button.  Left-clicking this button opens a connection editor, which
allows you to set up the input connections from other JACK ports to
the inputs for the strip.  A typical connection editor is shown in
<xref linkend="fig-input-connection-matrix"/>.
</para>

<figure id="fig-input-connection-matrix"> 
  <title>A mixer strip input connection editor</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/input-connection-matrix&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
In this case, we have an audio track called &lsquo;Audio 2&rsquo; which has a
single input.  At the bottom of the connection editor you can see a
label of &lsquo;Audio 2 in&rsquo;, which represents this input.  To the left of
the window are the places that this input can come from.  In the
example screenshot, we can see that two JACK ports called &lsquo;in 1+2&rsquo; are
shown, and there is a green dot which represents a connection between
the L channel of &lsquo;in 1+2&rsquo; and our track input.  The signal for &lsquo;in
1+2&rsquo; is coming from a sound card in the computer that Ardour is
running on.
</para>

<para>
The connection editor's behaviour is relatively straightforward.
Signals flow either from left to bottom or from top to right (so
generally &lsquo;left to right&rsquo;).  The tabs down the left-hand side of
the window indicate other groups of ports that signals can be obtained
from: other Ardour busses, Ardour tracks, Ardour miscellanous outputs
and Hardware.  Clicking in a square in the grid makes or breaks the
corresponding connection.  To make multiple connections at the same
time you can click and drag to &lsquo;draw&rsquo; connections in a
line.
</para>

<para>
An alternative to using the connection editor is to right-click on the
input button.  This will offer a menu with what Ardour expects may be
common choices for your strip's input ports.
</para>

</section>
<section><title>Processors</title>

<para>
A &lsquo;processor&rsquo; is a thing which treats the signal in some
way.  Ardour provides several processors, some of which are for
internal use and are not seen in the mixer strip.  In addition,
processors can also be plugins.  The arrangement of processors is
arbitrary, and there is no limit to how many there can be.
</para>

<para>
The main box in the top half of the mixer strip shows the processor
list.  Processors are shown as coloured rectangles, with a small &lsquo;LED&rsquo;
beside them; this indicates whether or not the plugin is enabled, and
can be clicked to enable or disable a processor.  The colour of the
processor depends on its location in the sequence; processors that
occur before the fader are coloured in red, and those after are
coloured green.
</para>

<para>
The processor box will always contain a blue processor called &lsquo;Fader&rsquo;.
This indicates where in the processor chain the main volume fader is
located &mdash; this is the fader in the bottom half of the strip.
</para>

<section>
<title>Moving processors around</title>

<para>
Processors can be moved around in the chain by dragging and dropping.
You can also drag processors from other strips in the mixer to copy
them into this strip.  
</para>

</section>
<section><title>Adding plugins</title>

<para>
Perhaps the most common use for the processor box is to add
<emphasis>plugins</emphasis>.  These are self-contained pieces of code which peform
some processing on the signal; typical examples of plugins might
include compressors, equalisers, reverbs and so on.
</para>

<para>
Plugins must be installed onto your computer before they can be used.
There are a variety of ways of doing this: on Linux, your distribution
may well include packages of plugins.  Alternatively, they can be
downloaded from various places on the internet, or can be bought from
commercial companies.
</para>

<!--% more detail about plugins availability, standards, etc. etc.-->

<para>
To add a plugin to a strip, right-click over the processor box and
choosing &lsquo;New Plugin&rsquo;.  You can choose one straight from the
menu, or open the &lsquo;Plugin Manager&rsquo; which gives a few extra
facilities for finding the right plugin.  Once a plugin is selected,
it will appear in the strip and start processing the signals that flow
down the strip.  Double-clicking on a plugin's name in the processor
box will open its editor window, which allows you to alter its
parameters.  Alternatively, right-clicking on the plugin and selecting
<guimenuitem>Show All Controls</guimenuitem> from the
<guimenu>Controls</guimenu> menu adds the plugins controls directly to
the processor box.  This may be convenient for plugins with few
controls, such as the plate reverb shown in the example screenshot.
</para>

</section>
<section><title>Sends</title>
<indexterm><primary>send</primary></indexterm>

<para>
Another type of processor that is available is the <emphasis>send</emphasis>.  A
send sits in the processor list, passing signals through untouched,
but also splits off (or &lsquo;sends&rsquo;) the signal somewhere else.  That
&lsquo;somewhere else&rsquo; can be a set of JACK ports or an Ardour bus.  Sends
are typically used for passing a track's signal to a reverb unit, or
perhaps to set up a headphone mix for an artist.
</para>

<para>
If the send is to an Ardour bus, we refer to it as an &lsquo;Aux send&rsquo;.
Such a send can be added to a strip by right-clicking in the processor
box and following the <guimenuitem>New Aux Send</guimenuitem> option.  The submenu offers
a list of the busses in the session, and you can choose the one that
the send should push its signal to.
</para>

<para>
Alternatively, a send to a set of JACK ports (an &lsquo;external
send&rsquo;) can be added using <guimenuitem>New External
Send</guimenuitem>.  On creating an external send, a connection editor
opens so that you can connect the send to wherever it needs to go.
This could be an audio card output (for sending to some headphones or
to a hardware effects unit), another JACK-based application that you
have running, or whatever.
</para>

<para>
Sends have a small fader in the processor box which controls the
amount of the strip's signal that they will send to their destination.
</para>

</section>
</section>
<section>
<title>Panning</title>

<para>
After passing through the processors, our signal arrives at the
panner.  The panner has the task of arranging however many channels of
audio we have at the end of our processor list to pass to the outputs.
This is reasonably simple in some cases (for example if we have a mono
track and stereo outputs), but can also be very complicated (it is not
immediately obvious, for example, how one might pan a 14-channel track
to 37 outputs).
</para>

<para>
Ardour will try to pick a good panner for each particular situation.
</para>

</section>
<section>
<title>Output ports</title>

<para>
Finally, the button at the very bottom of the strip sets where the
output signal from the strip will go.  Frequently, this will be the
master bus (and Ardour may auto-connect new tracks and busses to the
master, depending on its configuration).  As with the input ports, a
left-click on the output port button will open a connection editor,
and a right-click will open a menu of common options.
</para>

</section>
<section xml:id="sec-monitoring"><title>Monitoring</title>
<indexterm><primary>monitoring</primary></indexterm>

<para>
As we discussed earlier, there are two places that a track's signal
may come from: its JACK ports, or its files on disk.  The choice of
which to use at any given time is usually made automatically by
Ardour, depending on the configuration of its monitoring options.
</para>

<para>
&lsquo;Monitoring&rsquo; in Ardour is the general term used for the frequent need
to listen to signals that are coming into the computer, perhaps as
they are being recorded.  Often, for example, one might be playing an
instrument for a recording and might want to hear what one is doing at
the same time, perhaps along with some other existing tracks.
</para>

</section>
<section><title>Different ways of monitoring</title>

<para>
There are three basic ways in which monitoring may be approached:
</para>

<itemizedlist>
<listitem> External monitoring &mdash; this is where Ardour plays no
role in monitoring at all.  Perhaps the recording set-up has an
external mixer which can be used to set up monitor mixes, or perhaps
the sound-card being used has some &lsquo;listen to the
input&rsquo;-style feature.  This approach often has the advantage of
zero or near-zero latency.  On the other hand it requires external
hardware, and the monitoring settings are not saved with the session.
See <xref linkend="fig-external-monitoring"/> for a simple example
setup.

<figure id="fig-external-monitoring">
  <title>External monitoring</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/external-monitoring&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

</listitem>
<listitem> JACK-based &lsquo;hardware&rsquo; monitoring &mdash; some sound cards have the
  ability to mix signals from their inputs to their outputs with zero-
  or low-latency.  Furthermore, on some cards these features can be
  controlled by JACK.  This is a nice arrangement, if the sound card
  supports it, as it combines the convenience of having the monitoring
  controlled by Ardour with the low latency operation of doing it
  externally.  See <xref linkend="fig-jack-monitoring"/>.

<figure id="fig-jack-monitoring">
  <title>JACK-based &lsquo;hardware&rsquo; monitoring</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/jack-monitoring&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

</listitem><listitem> Software monitoring &mdash; this where all monitoring is performed
  by Ardour; it makes track inputs available at track outputs, under
  the influence of various controls.  This approach will almost always
  have more routing flexibility than JACK-based monitoring.  The
  disadvantage is that there will be a latency between the input and
  the output which will depend mainly on the JACK buffer size that is
  being used.

<figure id="fig-ardour-monitoring">
  <title>Software monitoring</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/ardour-monitoring&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

</listitem>
</itemizedlist>

<section><title>Setting up monitoring</title>

<para>
There are three main settings which affect how monitoring is
performed.  The first is &lsquo;Record monitoring handled by&rsquo; in
the <guilabel>Audio</guilabel> tab of the <guilabel>Ardour
Preferences</guilabel> dialogue.  There are two or three options here,
depending on the capabilities of your hardware:
</para>

<itemizedlist>
<listitem> <emphasis>ardour</emphasis> &mdash; Ardour handles monitoring itself (software monitoring).
</listitem><listitem> <emphasis>audio hardware</emphasis> &mdash; Ardour does no monitoring at all, and
  assumes you will do it yourself (external monitoring)
</listitem><listitem> <emphasis>JACK</emphasis> &mdash; Ardour will ask JACK to, in turn, ask the sound
  card to handle monitoring.  This option is only available if it is
  supported by your sound card (hardware monitoring).
  </listitem>
</itemizedlist>

<para>
The other two settings are more complex; one is &lsquo;Tape machine
mode&rsquo;, in the same dialogue, and the other is &lsquo;Monitoring
automatically follows transport state
(&lsquo;auto-input&rsquo;)&rsquo; setting in <guilabel>Session
Properties</guilabel>.
</para>

<para>
Monitoring is also somewhat dependent on the state of the track's
record-enable button, the session record enable button, and whether or
not the transport is rolling.
</para>

</section>
<section><title>Monitoring in software or hardware monitoring modes</title>

<para>
If Ardour is set to &lsquo;external monitoring&rsquo;, the explanation of Ardour's
monitoring behaviour is simple: it does not do any.  In the other two
modes, things are more complex.
</para>

</section>
<section><title>Monitoring in non-tape-machine mode</title>

<para>
This section describes what happens when Ardour is <emphasis>not</emphasis> set to
tape-machine mode.
</para>

<para>
Consider first the case when a track is record-enabled.  In this
situation, it will always monitor the live input <emphasis>unless</emphasis> the
session is <emphasis>not</emphasis> record-enabled, auto-input is enabled, and the
transport is rolling.  
</para>

<para>
When a track is not record-enabled, the track will play back its
contents from disc <emphasis>unless</emphasis> the transport is stopped and
auto-input is enabled.  In this case, the track monitors its live
input.
</para>

</section>
<section><title>Monitoring in tape-machine mode</title>

<para>
In tape-machine mode, things are slightly simpler; when a track is
record-enabled, its behaviour is the same as in non-tape-machine mode:
it will always monitor the live input <emphasis>unless</emphasis> the session is
<emphasis>not</emphasis> record-enabled, auto-input is enabled, and the transport is
rolling.
</para>

<para>
When a track is not record-enabled, however, the track will always
just play back its contents from disk; the live input will never be
monitored.
</para>

<!--
Some more rational explanation of why things are like this
Metering!
-->

</section>
</section>
</section>
<section><title>Overall signal flow and solo / mute</title>

<para>
The previous section explores how signals flow within individual mixer
strips.  This section discusses the wider picture of signal flow
within Ardour as a whole, particularly with regard to track soloing and
muting.
</para>

<section>
<title>The master bus</title>

<para>
Ardour sessions always contain a special bus called the <emphasis>master
  bus</emphasis>.  Mostly, this is like a normal bus, but it has some special properties:
</para>

<itemizedlist>
<listitem> Ardour can be configured to connect other tracks
  and busses to the master bus automatically.
</listitem><listitem> The master bus&rsquo; mixer strip is always displayed at the
  right-hand-side of the mixer window.
  </listitem>
</itemizedlist>

<para>
Typically, most of a session's tracks will send their output to the
master bus, and the output from the master bus will be connected to
some ports on a physical sound card so that the mix makes it
out into the real world to be listened to.
</para>

</section>
<section>
<title>The monitor bus</title>

<para>
The monitor bus is an additional, optional, and more specialised type
of bus.  Ardour can configured to use a monitor bus by ticking the
&lsquo;Use a monitor bus&rsquo; option in the <guilabel>Audio</guilabel> tab
of the <guilabel>Ardour Preferences</guilabel> dialogue.
</para>

<!-- XXX?
%% If you are using a monitor bus, an extra &lsquo;monitor control&rsquo; section will appear in the mixer window. -->

<para>
The monitor bus provides a quite large degree of extra control, and is
an approximation to the setup of a moderately complex mixing desk,
which often has a separate <emphasis>mix bus</emphasis> and <emphasis>monitor bus</emphasis>.  In
a live situation, for example, it is common for the mix bus to be
connected to the front-of-house speakers and the monitor bus to be
listened to on headphones.  In a studio, one might have the monitor
bus connected to the control room outputs and the mix bus connected to
a 2-track output recorder.
</para>

</section>
<section xml:id="sec-mute-and-solo">
<title>Mute and solo</title>

<para>
Each track and bus has two buttons which have important implications
for signal flow: <emphasis>mute</emphasis> and <emphasis>solo</emphasis>.  The behaviour of these
buttons is configurable in Ardour, so that they can behave in one of a
few different ways to suit different studio set-ups.
</para>

</section>
<section><title>Without a monitor bus</title>

<para>
If you are using Ardour <emphasis>without</emphasis> a monitor bus, there is only
one way in which mute and solo will work.  Without a monitor bus:
</para>

<itemizedlist>
<listitem> <emphasis>Mute</emphasis> on a track or bus will mute that track on the
  master bus, so that it will not be heard.
</listitem><listitem> <emphasis>Solo</emphasis> on a track or bus will solo that track or bus and
  mute all others <emphasis>except that</emphasis> soloing a bus will also solo any
  tracks or busses that feed that bus.
  </listitem>
</itemizedlist>

</section>
<section><title>With a monitor bus</title>

<para>
For setups <emphasis>with</emphasis> a monitor bus, you have more options, mostly
governed by the setting of the &lsquo;Solo controls are Listen controls&rsquo;
option in the <guilabel>Solo / mute</guilabel> tab of &lsquo;Ardour Preferences&rsquo;.
</para>

<para>
With &lsquo;Solo controls are Listen controls&rsquo; unticked, behaviour is almost
exactly the same as the situation without a monitor bus.  Mute and
solo behave the same, and the monitor bus is fed from the master bus,
so it sees the same thing.
</para>

<para>
With &lsquo;Solo controls are Listen controls&rsquo; ticked, things change; the
master and monitor busses behave differently.  In this mode, solo
controls are more properly called &lsquo;listen&rsquo; controls, and Ardour's solo
buttons will change their legend from &lsquo;S&rsquo; to either &lsquo;A&rsquo; or &lsquo;P&rsquo; (we'll
come to that shortly) to reflect this.
</para>

<para>
Now, without any mute or listen, the monitor bus remains fed by the
master bus.  Also:
</para>

<itemizedlist>
<listitem> <emphasis>Mute</emphasis> will mute the track or bus, so that it will not be
  heard anywhere (neither on the master nor monitor busses), much as before.
</listitem><listitem> <emphasis>Listen</emphasis> will disconnect the monitor bus from the master
  bus, so that the monitor bus now only receives things that are
  &lsquo;listened&rsquo;.  Listen will not perform any muting, and hence the
  master bus will not be affected by a listened track or bus.
  </listitem>
</itemizedlist>

<para>
There are further options with when solo controls are listen controls:
the part of the track or bus from which the listen signal is obtained
can be configured.  Underneath the &lsquo;Solo controls are Listen controls&rsquo;
option in &lsquo;Ardour Preferences&rsquo; is an option for &lsquo;listen position&rsquo;,
which can be either After-Fade Listen (AFL) or Pre-Fade Listen (PFL).
AFL, as its name suggests, obtains its signal from some point after
the track or bus&rsquo; fader, and PFL from before it.  The precise point to
get the signal from can further be configured using the &lsquo;PFL signals
come from&rsquo; and &lsquo;AFL signals come from&rsquo; options.
</para>

<para>
The solo-mute arrangement with a monitor bus is shown in <xref linkend="fig-solo-mute"/>.
</para>

<figure id="fig-solo-mute">
  <title>Solo and mute with a monitor bus</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/solo-mute&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Here we have a number of tracks or busses (in orange).  Each one has
an output which feeds the master bus.  In addition, each has PFL and
AFL outputs; we have a choice of which to use.  PFL/AFL from each
track or bus are mixed.  Then, whenever anything is set to AFL/PFL,
the monitor out becomes just those AFL/PFL feeds; the rest of the
time, the monitor out is fed from the master bus.
</para>

<para>
In this scheme Solo has no effect other than to mute other non-soloed
tracks; with solo (rather then listen), the monitor out is fed from
the master bus.
</para>

</section>
</section>
</chapter>

<!-- ====================================================================================
     EDITING
     ==================================================================================== -->

<chapter>
<title>Editing</title>

<para>
&lsquo;Editing&rsquo; is the name given to the process of manipulating recorded or
imported audio and MIDI data.  There is some common ground between the
two, but of course there are also differences.  This chapter discusses
Ardour's editing facilities for the two types of data.
</para>


<section><title>Basic region operations</title>

<para>
The region is the basic component of Ardour that we are concerned with
editing.  <xref linkend="fig-audio-region"/> shows a typical audio region.
</para>

<figure id="fig-audio-region">
  <title>An audio region</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/audio-region&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
In the region we can see a representation of the waveform of the audio
data for both the left and right channels (since this is a stereo
region).  At the bottom is a coloured bar containing the name of the
region.
</para>

<para>
There are few basic operations that can be performed on a region.
Left-clicking and dragging will move the region; regions can be moved
in time, or to a different track.  &modone;-dragging will make a copy
of the region and start moving it.  
</para>

<para>
Clicking and dragging towards the left or right side of the region, or
anywhere within the &lsquo;trim bar&rsquo;, trims the start or end of the region.
<xref linkend="fig-audio-region-trim"/> shows a trim in progress.
</para>

<figure id="fig-audio-region-trim">
  <title>Trimming the end of an audio region</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/region-trim-end&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Right-clicking anywhere on a track (including over a region) displays
the track menu.  The top entry in this menu will be the name of the
region that was clicked on, and this entry's submenu offers a large
selection of operations which can be applied to the region.  These
operations are described in Chapter <xref linkend="ch-region-ops"/>.
</para>

<section>
<title>Splitting regions</title>

<para>
Regions can be split into two or more new regions using the
&lsquo;split&rsquo; command.  This is available from the region context
menu's <guimenu>Split</guimenu> item from the <guimenu>Edit</guimenu>
menu.  (or bound to <keycap>S</keycap>).  The split will happen at the
edit point (see <xref linkend="sec-edit-point-selector"/>).
</para>

<!-- This logic is in the comment for Editor::get_regions_from_selection_and_edit_point() -->

<para>
The way in which Ardour decides <emphasis>which</emphasis> regions to split is a
little involved as it depends on the edit point that is being used.
</para>

<para>
If the edit point is &lsquo;mouse&rsquo; and you are pointing at an unselected
region, that region will be split; otherwise, regions on any tracks
with selected regions will be split if they lie at the time that the
mouse pointer is at.
</para>

<para>
If the edit point is &lsquo;playhead&rsquo; or &lsquo;marker&rsquo;, any regions underneath
the edit point on tracks that are either themselves selected, or
contain selected regions, will be split.
</para>

<para>
This makes more sense in practice than it does written down!  In
general, the easiest approach to getting the split you want is often
to select the regions that you want to split, put the edit point at
the split, then hit &lsquo;S&rsquo;.
</para>

<para>
If tracks which have regions to be split are themselves members of
groups (see <xref linkend="sec-track-and-bus-groups"/>) that have the
&lsquo;share edit&rsquo; property set, the other members of the group will also be
examined for regions to split.
</para>


</section>
</section>
<section><title>Duplicating regions</title>


</section>
<section xml:id="sec-overlapping-regions"><title>Overlapping regions</title>
<indexterm><primary>overlap</primary></indexterm>

<para>
A track can have regions which overlap in time.  When this happens,
several factors determine what output the track will generate.
</para>

<para>
A track (or really, a playlist) is considered to have its regions in a
stack.  That is, they are ordered, as if they were placed in a pile.
Thus, with overlapping regions, there are regions which are above or
beneath others.  With the default settings, Ardour will play the
topmost region in the stack at any particular point in time.  This is
shown in <xref linkend="fig-overlapping-regions"/>.
</para>

<figure id="fig-overlapping-regions"> 
  <title>Some overlapping regions</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/overlapping-regions&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The diagram shows a collection of regions, expanded so that you can
see how they are stacked.  The green areas show the bits that Ardour
will play by default.
</para>

<para>
The initial stacking order of regions is simple: the more recently the
region was added to the track (by whatever means: recording,
importing, copying etc.) the higher in the stack it will be.  If this
intial stacking is not what you need, there are a few ways that it can
be manipulated.  Note that the initial stacking is just that:
<emphasis>initial</emphasis>.  Any modifications that you make to stacking order
will be remembered by Ardour.
</para>



<section><title>Raising and lowering overlapping regions</title>

<para>
Most simply, regions can be raised or lowered in the stack using
options in the region context menu under
<guimenuitem>Layering</guimenuitem>; regions can be raised or lowered
either by one level or right to the top or bottom of the stack.
</para>

<para>
Another option is to put a region's track into
<emphasis>stacked</emphasis> mode.  To do this, right-click on the
track controls area and choose <guimenuitem>Stacked</guimenuitem> from
the <guimenu>Layers</guimenu> menu. In this mode, rather than
overlapping regions being drawn on top of each other, regions are
drawn more like those in <xref linkend="fig-overlapping-regions"/>.
This makes the arrangement of the track's regions a little more
obvious.  Areas of regions that will not be played back are shaded
dark-grey to make things clearer.
</para>

<para>
In this mode, it is possible to move regions up and down in the stack
just as you would move them around normally.  Dragging a region makes
all the regions on the track &lsquo;jump&rsquo; apart on the display; at this
point, the region that you are dragging can be moved anywhere within
the stack.
</para>

</section>
</section>

<section><title>Audio region fades</title>
<indexterm><primary>fade</primary></indexterm>

<para>
Audio regions have a few properties of their own, with respect to
MIDI.  One is that they have optional <emphasis>fades</emphasis> at their
beginning and end.  A fade is effectively a change in gain; the start
of the region fades from -&infin;dB to 0dB and the end fades from
0dB out to -&infin;dB.  
</para>

<para>
These fades can be of any length and a variety of shapes.
<xref linkend="fig-region-fades"/> shows some regions with some examples of fades.
</para>

<figure id="fig-region-fades">
  <title>Some regions with fades</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/region-fades&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
When the mouse pointer is over an audio region, fade handles will
appear and the fades&rsquo; lengths can be changed, as shown in
<xref linkend="fig-dragging-fades"/>.
</para>

<figure id="fig-dragging-fades">
  <title>Dragging a fade-in</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/dragging-fades&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
The shape of the fade can be changed by right-clicking over the fade;
this will pop up a menu as in <xref linkend="fig-fades-menu"/>.
</para>

<figure id="fig-fades-menu">
  <title>Fade shape menu</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/fades-menu&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<section><title>Cross-fading</title>
<indexterm><primary>crossfade</primary></indexterm>

<para>
Region fades have an important consequence in addition to fading their
subject region.  At the same time as providing a gain change to the
target region, the fades also cause an <emphasis>inverse</emphasis> fade to any
regions that lie beneath the target region in the stack.
</para>

<para>
Consider, for example, the simple case in <xref linkend="fig-crossfades"/>.
</para>

<figure id="fig-crossfades">
  <title>Simple cross-fade</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/crossfades&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
We have two regions, A and B.  For the first part of this time,
region A plays (its area marked green).  Then we have region B,
which overlaps A, and has a fade-in.  Ardour sees this fade-in and
automatically performs a fade-out on region A which is the inverse
of B's fade-in.  During the period of B's fade in, both region A
and B will be heard.  This fade-in/fade-out arrangement has the
important effect that no &lsquo;click&rsquo; will be heard due to the
discontinuity between the waveforms of regions A and B.  This
arrangement, where one thing is fading out at the same time that
another is fading in, is called <emphasis>cross-fading</emphasis>.
</para>

<para>
So useful is this property that Ardour will arrange for cross-fades to
be present whenever regions overlap.  There are some options to decide
what form these automatically-generated crossfades will take, as
described in <xref linkend="sec-session-properties-fades"/>.  The
automatic crossfades can be set to span the entire overlap of the
regions involved, or to be short.  In general, if you want the basic
property of &lsquo;de-clicking&rsquo; region overlaps, crossfades should be set to be
&lsquo;short&rsquo;.  The long-crossfade options are more useful for
artistic use of fades, where two regions must merge slowly into each
other.
</para>


</section>
</section>
<section xml:id="sec-audio-region-gain"><title>Audio region gain</title>
<indexterm><primary>gain!region</primary></indexterm>

<para>
In addition to the fade-in and fade-out curves, there are two other
ways to modify the gain of a region; as with fades, these
modifications are non-destructive &mdash; they do not alter the data
on the disk.  Firstly, a region has an overall gain which is applied
to the whole region.  On top of this, regions can have <emphasis>gain
envelopes</emphasis> which modify the gain over time.
</para>

<para>Simple gain changes across the whole region can be made in a few
ways:
</para>

<itemizedlist>
<listitem>
Using the <guimenuitem>Boost Gain</guimenuitem> and <guimenuitem>Cut
Gain</guimenuitem> options on the <guimenu>Gain</guimenu> submenu of
the region context menu; these adjust the overall gain in 1dB steps.
</listitem>
<listitem>
Using normalisation (the <guimenuitem>Normalize&hellip;</guimenuitem>
option on the <guimenu>Gain</guimenu> submenu); this will set the
region's scale amplitude so that, when played back, its maximum level
is just below 0dBFS.
</listitem>
<listitem>
From the region properties dialogue box, accessible using
<guimenuitem>Properties&hellip;</guimenuitem> from the region context
menu.
</listitem>
</itemizedlist>

<para>
For more involved changes to region gain, regions can also have their
own variable gain envelopes.  This overlaps somewhat with automation
(discussed in Chapter <xref linkend="ch-automation"/>), but can be
useful to alter the sound of particular features within the region.
</para>

<para>
If you want to modify audio region gain, it is important to ensure
that the option &lsquo;Show gain envelopes in audio regions&rsquo; is ticked in
the <guilabel>Editor</guilabel> tab of Ardour's preferences (see
<xref linkend="sec-ardour-preferences-editor"/>).  This enables some
useful functionality which is otherwise turned off.
</para>

<para>
To edit audio region gain, first go into &lsquo;draw region gain&rsquo; mode by
clicking the tool (<imagedata scale="75" fileref="screenshots/tool-region-gain&scs;"/>).  Now,
moving the mouse pointer over an audio region will show the gain
curve; initially this will be a straight green line with two
red-square points, one at each end.  The gain line can be edited in
the following ways:
</para>

<itemizedlist>
<listitem> Left-clicking in an empty area of the region will add a new
  region gain line point.
</listitem><listitem> Dragging a point will move it.
</listitem><listitem> Dragging a line segment will move points at each end of the segment.
</listitem><listitem> Right-clicking on a point will offer a small
  menu from which you can delete the point or edit its value
  numerically.
</listitem><listitem> &modone;-right-clicking on a point is a short-cut to opening
  its edit dialogue box.
</listitem><listitem> &modtertiary;-right-clicking on a point will delete it.
</listitem>
</itemizedlist>

<para>
An example region with a gain line is shown in
<xref linkend="fig-region-with-gain-line"/>.
</para>

<figure id="fig-region-with-gain-line">
  <title>An audio region with a gain line</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/region-gain-line&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>


</section>
<section><title>Pitch shifting</title>

<para>
Ardour provides algorithms to do pitch-shifting of audio.  As with any
pitch-shifting method, the results can never be perfect, but they may
be useful for correction or for artistic purposes.  To pitch-shift a
region, choose <guimenuitem>Pitch Shift&hellip;</guimenuitem> from the
<guimenu>Edit</guimenu> submenu of the context menu.  This will open
the <guilabel>Pitch Shift Audio</guilabel> dialogue box, which allows you to
specify the desired shift in octaves, semitones and cents.
</para>

<!-- Preserve Formants? -->

</section>
<section><title>Time stretching</title>

<para>
Time-stretching in Ardour has its own special tool.  Choose the
stretch/shrink tool (<imagedata scale="75" fileref="screenshots/tool-stretch&scs;"/>).
With this tool, you can click and drag the size of regions, much as
you would do when trimming them.  The difference is that after the
drag, Ardour will time-stretch the region to the new size that you
have requested.  For audio regions, a dialogue box will appear so that
you can set up the parameters of the time-stretching algorithm.  For
MIDI, of course, time-stretching is somewhat easier and requires no
options.
</para>

</section>
<section>
<title>Stripping silence</title>

<para>
With some recordings, it is desirable to remove regions which are, or
are &lsquo;nearly&rsquo;, silent.  This can be done automatically using the
<guimenuitem>Strip Silence&hellip;</guimenuitem> item on the region
context&rsquo;s menu <guimenuitem>Edit</guimenuitem> item.  Selecting this
option will open the dialogue shown in <xref
linkend="fig-strip-silence-dialogue"/>.
</para>

<figure id="fig-strip-silence-dialogue"> 
  <title>The strip silence dialogue</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/strip-silence-dialogue&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
In addition, your target regions will be overlaid with light-blue
areas which represent that the strip silence dialogue currently
considers &lsquo;silence&rsquo;.  The main adjustment for this is the threshold;
this is the level below which the region will be considered silent.
In addition, the minimum length of a silent period can be specified,
so that shorter below-threshold periods will be ignored.
</para>

<para>
Finally, the dialogue offers a &lsquo;fade length&rsquo; option which specifies
what length of fade in and out will be applied if &lsquo;Apply&rsquo; is pressed
and some parts are stripped out of the region.
</para>

<para>
Clicking &lsquo;Apply&rsquo; will split the target regions as required, leaving
only those areas which it considers non-silent.
</para>

</section>
<section><title>Rhythm Ferret</title>

<para>
Rhythm Ferret is a tool which can analyse regions in a couple of
different ways, looking for particular features (like note onsets or
transients like percussion hits).  It can then perform various
operations on the region based on these features.
</para>

<para>
To open the <guilabel>Rhythm Ferret</guilabel> dialogue, choose
<guimenuitem>Rhythm Ferret</guimenuitem> from the
<guimenu>Edit</guimenu> menu.  This will open the dialogue box shown
in <xref linkend="fig-rhythm-ferret-dialogue"/>.
</para>

<figure id="fig-rhythm-ferret-dialogue"> 
  <title>The Rhythm Ferret dialogue</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/rhythm-ferret-dialoug&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
First, choose the features that you want to look for; either note
onset or percussive onset.  Then, clicking &lsquo;Analyse&rsquo; will examine
region and place light grey markers at the detected features in the
region.  If the features have been detected incorrectly, you can
adjust the parameters and click &lsquo;Analyse&rsquo; to try again.  Once the
correct features have been found, you can choose what to do with them
using the &lsquo;Operation&rsquo; drop-down:
</para>

<!--Not sure what the parameters do -->

<itemizedlist>
<listitem>
<emphasis>Split region</emphasis> &mdash; this will split the region
into smaller regions at the feature points.
</listitem>
<listitem>
<emphasis>Snap region &mdash; <!-- don't know what these do --> </emphasis>
</listitem>
<listitem>
<emphasis>Conform regions</emphasis> &mdash; 
</listitem>
</itemizedlist>

</section>
<section xml:id="sec-spectral-analysis"><title>Spectral analysis</title>
<indexterm><primary>spectrum</primary></indexterm>

<para>
Though not strictly an editing operation, Ardour provides a handy
window which gives a spectral analysis of some part of your session.
You can use this to see a spectral analysis of a region by choosing
<guimenuitem>Spectral Analysis&hellip;</guimenuitem> from the region&rsquo;s context menu.
</para>

</section>
<section><title>MIDI region editing</title>

<para>
MIDI regions are somewhat different to audio regions in that Ardour
allows you to edit their contents, as well as just their position and
size.  With a midi region's tools you can add, move, delete and modify
notes, control changes and so on directly inside the editor window.
</para>

<para>
The first step to editing a MIDI region's contents is to click the
&lsquo;edit region contents&rsquo; tool (<imagedata scale="75" fileref="screenshots/tool-region-contents&scs;"/>).
On doing this, the bodies of the regions in the session will fade out
to indicate that you are now editing their contents.  You can also
edit this mode by double-clicking on a MIDI region.
</para>

<para>
<xref linkend="fig-midi-edit1"/> shows a region with &lsquo;edit region contents'
disabled, and <xref linkend="fig-midi-edit2"/> after &lsquo;edit region contents'
has been switched on.
</para>

<figure id="fig-midi-edit1"> 
  <title>A MIDI region with &lsquo;edit region contents&rsquo; switched off</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/midi-edit1&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<figure id="fig-midi-edit2"> 
  <title>A MIDI region with &lsquo;edit region contents&rsquo; switched on</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/midi-edit2&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Once in this mode, many of the tools for altering regions become tools
for altering notes.  With the &lsquo;select/move objects&rsquo; tool
(<imagedata scale="75" fileref="screenshots/tool-objects&scs;"/>) you can select notes, move them
around and trim their starts and ends.  Hovering the mouse over a note
will display information about its note value, channel and velocity.
</para>

<para>
Right-clicking on a selected note will display a channel selector, as
shown in <xref linkend="fig-midi-edit5&scs;"/>.
</para>

<figure id="fig-midi-edit5"> 
  <title>Altering a note's channel</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/midi-edit5&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Once this is displayed, click on the MIDI channel that you want the
note to be played back on.
</para>

<para>
The full gory details of a note can be edited numerically by
&modone;-right-clicking a selected note.  This opens a dialogue box
with all the notes details; modifying the values in the dialogue box
will change the note.
</para>


<section>
<title>Cutting, copying and pasting notes</title>

<para>
Selected notes can be cut using <keycap>&modone;-X</keycap>, copied with
<keycap>&modone;-C</keycap> and deleted with <keycap>Delete</keycap>, just as regions can.
Once cut or copied they can also be pasted; pastes will be placed at
the current edit point (see <xref linkend="sec-edit-point-selector"/>).
</para>

</section>
<section><title>Adding notes</title>

<para>
Notes can be added to MIDI regions using the &lsquo;draw MIDI&rsquo; tool
(<imagedata scale="75" fileref="screenshots/tool-draw-midi&scs;"/>).  Select this tool, then click
to add a note which is the same length as the current grid interval,
or click and drag to add a note of any length.
</para>

</section>
</section>
<section><title>Other MIDI operations</title>

<para>
When outside of &lsquo;edit region contents mode&rsquo;, some other (region-wide)
MIDI operations are available from the <guimenuitem>MIDI</guimenuitem> submenu of the
region context menu.
</para>


<section><title>Transpose</title>
<indexterm><primary>transpose</primary></indexterm>

<para>
This opens a dialogue box to allow transposition (shifts in pitch) of
the notes in the region.
</para>

</section>
<section><title>Insert Patch Change</title>

<!-- hmm -->

</section>
<section><title>Quantize</title>
<indexterm><primary>quantize</primary></indexterm>

<para>
The Quantize feature allows notes in the region to be snapped to a
grid, to make their timing more accurate.  The
<guimenuitem>Quantize&hellip;</guimenuitem> option opens the dialogue
shown in <xref linkend="fig-quantize"/>.
</para>

<figure id="fig-quantize"> 
  <title>The quantization dialogue</title>
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/quantize&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

The quantization options are as follows:

<itemizedlist>
<listitem>
<emphasis>Snap note start</emphasis> &mdash; tick the box to quantize note
  starts, and select the grid that they should be snapped to.
</listitem>
<listitem>
<emphasis>Snap note end</emphasis> &mdash; tick the box to quantize note
  ends, and select the grid that they should be snapped to.
</listitem>
<listitem>
<emphasis>Threshold</emphasis> &mdash; if a note start or end is more than this
  threshold (in ticks) away from a grid line, it will not be snapped.
  There are 1920 ticks per beat.
</listitem>
<listitem>
<emphasis>Strength</emphasis> &mdash; this is a percentage by which note starts
  or ends will be pulled towards the grid; if strength is set to 100,
  they will be snapped completely; any less, and they will be snapped
  less accurately.  This can be used to maintain some of the &lsquo;human&rsquo;
  inaccuracies in timing from a recording of a real player.
</listitem>
<listitem>
<emphasis>Swing</emphasis> &mdash; if ticked, this option will attempt to
  quantize notes so that they &lsquo;swing&rsquo;.  Speaking mathematically, given
  two input notes as shown in <xref linkend="fig-swing"/>, the
  quantizer will put the second note at a time t where

<!--
\begin{equation}
t = q + \frac{2}{3} \frac{F_S}{100} L
\end{equation}
-->

<para>
where F<subscript>S</subscript> is the swing factor specified in the <guilabel>Quantize</guilabel>
dialogue box.  Hence if F<subscript>S</subscript> is positive, the note will be placed
later than it would be with &lsquo;straight&rsquo; timing, and if F<subscript>S</subscript> is
negative the note is placed earlier.
</para>

<para>
This feature is probably most easily explored by listening!
</para>

<figure id="fig-swing"> 
  <title>The mathematics of swing</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/swing&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<indexterm><primary>swing</primary></indexterm>
</listitem>
</itemizedlist>

</section>
<section><title>Fork</title>
<indexterm><primary>fork</primary></indexterm>

<para>
By default, when a region is copied its contents are a
&lsquo;clone&rsquo; of the thing it was copied from.  That is to say,
if you copy some region A as region B, then edit region A, the same
edits will happen to region B.  This is not apparent for audio, since
the actual contents of audio regions cannot be changed, but it is
important for MIDI.  If you copy a region which you then want to be
independent of other regions in the session, select the region to make
independent and choose <guimenuitem>Fork</guimenuitem> item from the
<guimenu>MIDI</guimenu> part of the context menu.
</para>

</section>
<section><title>List Editor</title>
<indexterm><primary>list editor</primary></indexterm>

<para>
To look at the MIDI note events in a region numerically, select the
region and choose <guimenuitem>List Editor&hellip;</guimenuitem> from
the context menu's <guimenu>MIDI</guimenu> item.  This opens a
dialogue box containing all the region's note details, and edits you
make to the numbers will be reflected in the region.
</para>

</section>
</section>
<section xml:id="sec-midi-non-note"><title>MIDI data other than notes</title>

<para>
Ardour treats all MIDI note data differently to other types of
messages (control changes, pitch bends and so on).  All the other
types of data are represented as automation data, drawn with
continuous lines.  The resulting &lsquo;automation&rsquo; is converted back to
MIDI and played back in the same stream as the note data, and MIDI
automation data is always attached to a region, so it moves in time
and is copied and pasted with its region.
</para>

<para>
Automation is covered full in Chapter <xref linkend="ch-automation"/>, with
reference to audio as well as MIDI automation.
</para>

</section>
</chapter>


<!-- ====================================================================================
% AUTOMATION
% ==================================================================================== -->

<chapter xml:id="ch-automation">
<title>Automation</title>
<indexterm><primary>automation</primary></indexterm>

<para>
Automation is the means by which many controls in Ardour (faders,
plugin controls, mute and solo, and so on) can be &lsquo;automated&rsquo;, so that
their values change over time.  This is commonly used to assist with
mixing a track; vocal levels may be brought up and down as required,
for example.  This chapter describes the ways in which automation may
be set up and edited.
</para>

<section>
<title>Adding an automation lane</title>

By default, a track has no automation.  To add some, the first step is
to open an automation &lsquo;lane&rsquo; for the track.  This looks much like an
additional track, but can be considered a &lsquo;child&rsquo; of its parent track.

<para>
To create an automation lane for an audio track, click the &lsquo;a&rsquo; button
in the track controls area.  A menu will open which contains a list of
the things which can be automated for the track.  By default, this
will just be &lsquo;fader&rsquo; and &lsquo;pan&rsquo;, but if the track has any plugins,
their controls will also be listed in this menu.
</para>

<para>
Choosing, for example, &lsquo;fader&rsquo; opens a new automation lane, as shown
in <xref linkend="fig-automation-lane"/>.
</para>

<figure id="fig-automation-lane"> 
  <title>An automation lane</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/automation-lane&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
We now have an automation lane for the track &lsquo;up_with_people.stereo&rsquo;
which controls its fader level.  The automation lane's controls area
includes the name of the parameter being automated, a handy fader for
adjusting the level of the parameter, a button to select the
automation mode, and a &lsquo;cross&rsquo; button to hide the automation lane.
Hiding the automation lane merely removes it from sight; it does not
have any effect on the automation that the lane contains.
</para>

</section>
<section><title>Automation modes</title>

<para>
Clicking on the automation lane's mode button (which initially says &lsquo;Manual&rsquo;) offers four options:
</para>

<itemizedlist>
<listitem> <emphasis>Manual</emphasis> &mdash; in this mode the automation will be ignored on playback.
</listitem><listitem> <emphasis>Play</emphasis> &mdash; in this mode the automation will be &lsquo;played
  back'; in other words, when the session is playing back, the track's
  controls will be manipulated by any automation that has been set up.
</listitem><listitem> <emphasis>Write</emphasis> &mdash; when the session is being played back, any
  automation lanes in &lsquo;write&rsquo; mode will store data from the current
  value of their parameter at each instant.  In other words, one way
  to create automation data is to set &lsquo;write&rsquo; mode, play the session
  back, then adjust the parameter (in this case the fader) of the
  track as required.  Your movements will be recorded and written as
  automation.
</listitem><listitem> <emphasis>Touch &mdash; <!-- doesn't seem to work right now --></emphasis>
</listitem>
</itemizedlist>

</section>
<section><title>Creating automation</title>

<para>
There are two basic ways to create automation data.  Firstly, one may
use the &lsquo;write&rsquo; mode, as discussed in the previous section.  To see
this in action for our example fader lane, simply select &lsquo;write&rsquo;,
start the session, and move the track's fader around a bit.  When you
stop the transport, an automation line will appear on the lane to show
you the moves that you made on the fader.
</para>

<para>
The other option is to draw the automation with the mouse.  Clicking
in an automation lane with in &lsquo;select/move objects&rsquo; mode
(<imagedata scale="75" fileref="screenshots/tool-objects&scs;"/>) will create a new automation point.
</para>

</section>
<section><title>Editing automation</title>

<para>
Automation may be edited using the mouse in the automation lane.
Hovering the mouse over an automation line will put red squares at
each node of the line; these can be dragged around to move them.
</para>

<para>
You can also &modone;-right-click to display a dialogue box to change
the precise value of an automation point, or
&modtertiary;-right-click to delete a point.
</para>

<para>
Multiple points can be selected so that they can be moved as a group;
either &modone;-left-click to select additional points, or drag a
&lsquo;lassoo&rsquo; rectangle over a group of points to select several at once.
</para>

<para>
Finally, points may be cut, copied and pasted, just as regions, by
selecting them and using the standard key shortcuts <keycap>&modone;-X</keycap>
for cut, <keycap>&modone;-C</keycap> for copy or
<keycap>&modone;-V</keycap> for paste).  Pastes are made at the edit
point.
</para>

</section>
<section><title>MIDI &lsquo;automation&rsquo;</title>

As discussed in <xref linkend="sec-midi-non-note"/>, a variety of MIDI
message types are presented in Ardour as automation.  Lanes for these
messages can be opened, just as with audio tracks, by clicking on the
&lsquo;a&rsquo; button in a MIDI track's control area and selecting a parameter.
The menu is much more extensive for MIDI, since there is an option for
each parameter on each MIDI channel.

Note that because of the way MIDI automation is stored (with the
region), it is not possible to draw MIDI automation in an area of the
lane where its parent track does not have a region.  If you want to
add automation without any note data, simply create an empty region
before adding the automation.

</section>
</chapter>

<!-- ====================================================================================
    REGION OPERATIONS
    ==================================================================================== -->

<chapter xml:id="ch-region-operations">
<title>Region operations</title>

<para>
This chapter provides a reference to the operations that can be
performed on regions, accessible from the region submenu of the track
context menu.
</para>

<itemizedlist>

<listitem>
<emphasis>Play</emphasis> &mdash; start playback from the start of the region.
</listitem>
<listitem>
<emphasis>Loop</emphasis> &mdash; set the loop range to cover the region and begin looped playback.
</listitem>
<listitem>
<emphasis>Rename&hellip;</emphasis> &mdash; open a dialogue box to rename the region.
</listitem>
<listitem>
<emphasis>Properties&hellip;</emphasis> &mdash; open a dialogue box to view (and edit) the properties of the region.
</listitem>

<listitem><emphasis>Edit</emphasis>

<itemizedlist>
<listitem>
Combine
</listitem>
<listitem>
Uncombine
</listitem>
<listitem>
<emphasis>Split</emphasis> &mdash; split the region at the current
edit point; this will only work from the menu if the edit point is not
&lsquo;mouse&rsquo; (as if you are selecting a menu option, the mouse
position at the time is not particularly relevant to where an edit
point should be).
</listitem>
<listitem>
<emphasis>Make Mono Regions</emphasis> &mdash; given a multi-channel
(stereo or more) region, this option creates a new region per channel
and adds those regions to the session's region list.  These regions
can then be dragged from the editor region list (see <xref
linkend="sec-region-list"/>) into mono tracks as required.
</listitem>
<listitem>
<emphasis>Opaque</emphasis> &mdash; tick to make the region
&lsquo;opaque&rsquo;, so that regions underneath it on the playlist
will not be heard.  If the region is not opaque, its data will be
mixed with regions underneath it.
</listitem>
<listitem>
<emphasis>Mute</emphasis> &mdash; tick to mute the region; it will not be heard
</listitem>
<listitem>
<emphasis>Pitch Shift&hellip;</emphasis> &mdash; open a dialogue box
to pitch-shift the region.
</listitem>
<listitem>
<emphasis>Reverse</emphasis> &mdash; flip the region backwards in time.
</listitem>
<listitem>
Glose Gaps
</listitem>
<listitem>
Place Transient
</listitem>
<listitem>
Rhythm Ferret&hellip;
</listitem>
<listitem>
Strip Silence&hellip;
</listitem>
</itemizedlist>

</listitem>


<listitem>Position

<itemizedlist>
<listitem>
Move to Original Position
</listitem>
<listitem>
<emphasis>Lock</emphasis> &mdash; this will prevent the region from being moved.
</listitem>
<listitem>
Glue to Bars and Beats
</listitem>
<listitem>
Snap Position To Grid
</listitem>
<listitem>
Set Sync Position
</listitem>
<listitem>
Remove Sync
</listitem>
<listitem>
Nudge Forward
</listitem>
<listitem>
Nudge Backward
</listitem>
<listitem>
Nudge Forward by Capture Offset
</listitem>
<listitem>
Nudge Backward by Capture Offset
</listitem>
</itemizedlist>

</listitem>
 

<listitem>
Trim

<itemizedlist>
<listitem>
<emphasis>Trim Start at Edit Point</emphasis> &mdash; trims the region
so that it starts at the edit point, if that makes sense.
</listitem>
<listitem>
<emphasis>Trim End at Edit Point</emphasis> &mdash; trims the region
so that it ends at the edit point, if that makes sense.
</listitem>
<listitem>
<emphasis>Trim to Loop</emphasis> &mdash; trims the region's start and
end so that they are at the time of the loop range's start and end
respectively.
</listitem>
<listitem>
<emphasis>Trim to Punch</emphasis> &mdash; much as &lsquo;Trim to
Loop&rsquo; except with reference to the loop range.
</listitem>
<listitem>
<emphasis>Trim to Previous</emphasis> &mdash; trims the region's start
point so that it lies at the end point of the previous region in time
(if possible).
</listitem>
<listitem>
<emphasis>Trim to Next</emphasis> &mdash; trims the region's end point
so that it lies at the start point of the next region in time (if
possible).
</listitem>
</itemizedlist>

</listitem>

<listitem>Layering; manipulates region layers, as discussed in <xref linkend="sec-overlapping-regions"/>

<itemizedlist>
<listitem>
<emphasis>Raise to Top</emphasis> &mdash; moves the region to the top
layer of the stack.
</listitem>
<listitem>
<emphasis>Raise</emphasis> &mdash; moves the region one step closer to
the top of the stack.
</listitem>
<listitem>
<emphasis>Lower</emphasis> &mdash; moves the region one step closer to
the bottom of the stack.
</listitem>
<listitem>
<emphasis>Lower to Bottom</emphasis> &mdash; moves the region to the
bottom layer of the stack.
</listitem>
</itemizedlist>

</listitem>

<listitem>
Ranges

<itemizedlist>
<listitem>
Set Loop Range &mdash; this sets the loop range (see <xref
linkend="sec-markers"/>) so that it surrounds the currently-selected
regions.
</listitem>
<listitem>
Set Punch &mdash; this sets the punch range (see <xref
linkend="sec-markers"/>) so that it surrounds the currently-selected
regions.
</listitem>
<listitem>
Add Single Range Marker &mdash; this adds a single range marker (see
<xref linkend="sec-markers"/>) around the whole set of selected
regions.
</listitem>
<listitem> 
Add Range Marker Per Region &mdash; this adds an individual range marker around each selceted region (see
<xref linkend="sec-markers"/>).
regions.
</listitem>
<listitem>
Set Range Selection &mdash; this sets the time range selection to surround all selected regions.
</listitem>
</itemizedlist>

</listitem>

<listitem>
Gain &mdash; these items adjust a region's gain property.  This value is used only
to modify the gain of the region during playback; it does not modify the
data on disk.

<itemizedlist>
<listitem>
<emphasis>Normalize&hellip;</emphasis> &mdash; examines the contents of
the region and sets the region's gain so that the peak value of the
region is scaled to just under 0dbFS; in other words, this makes the
region as loud as it can be without introducing distortion.
</listitem>
<listitem>
Boost Gain &mdash; increases the region's gain by 1dB.
</listitem>
<listitem>
Cut Gain &mdash; decreases the region's gain by 1dB.
</listitem>
<listitem>
Reset Envelope &mdash; this resets the region's gain envelope to be a
straight line at 0dB (see <xref linkend="sec-audio-region-gain"/>).
</listitem>
<listitem> 
Envelope Active &mdash; if this option is ticked, the region's gain
envelope is followed, otherwise it is ignored.
</listitem>
</itemizedlist>

</listitem>

<listitem>
Fades

<itemizedlist>
<listitem>
Fade In &mdash; this is ticked if all regions in your selection have
active fade-ins, and unticked if non do; selecting the menu option
will toggle the active state of all selected regions' fade-ins.
</listitem>
<listitem>
Fade Out &mdash; this option behaves the same as <guimenuitem>Fade In</guimenuitem>, but
for fade-outs.
</listitem>
<listitem>
Fades &mdash; this option behaves the same as <guimenuitem>Fade
In</guimenuitem> and <guimenuitem>Fade Out</guimenuitem>, but applies
to both fades at the same time.
</listitem>
</itemizedlist>
</listitem>

<listitem>
Duplicate

<itemizedlist>
<listitem>
Duplicate &mdash; this option makes a copy of each selected region,
and places the duplicate regions directly after the end of the latest
selected region; if there is just one selected region, this means that
a duplicate copy will be placed right after the original.
</listitem>
<listitem>
Multi-Duplicate&hellip; this makes duplicates as per the
<guimenuitem>Duplicate</guimenuitem> option, but offers a choice of
how many should be made.  The count can be a fraction, in which case
the last duplicated region will be truncated.  If, for example, you
choose 2.5 duplicates, this will make 2 complete duplicates and one
futher duplicate which is half the length of the others.
</listitem>
<listitem>
Fill Track &mdash; this makes sufficient duplicates to fill the track
up to the session end marker.
</listitem>
</itemizedlist>
</listitem>

<listitem>
Export&hellip;
</listitem>
<listitem>
Bounce (without processing)
</listitem>
<listitem>
Bounce (with processing)
</listitem>
<listitem>
<emphasis>Spectral Analysis&hellip;</emphasis> &mdash; show a
frequency spectrum of the region (see <xref
linkend="sec-spectral-analysis"/>).
</listitem>
<listitem>
Remove
</listitem>


</itemizedlist>
</chapter>



<!-- ====================================================================================
     CONFIGURATION
     ==================================================================================== -->

<chapter>
<title>Configuration</title>

<para>
This chapter gives a reference to the ways in which Ardour's behaviour
can be customised.
</para>

<section>
<title>Per-session and global options</title>

<para>
Options are split into two groups: <emphasis>session
properties</emphasis> (accessible from the
<guimenuitem>Properties</guimenuitem> item on the
<guimenu>Session</guimenu> menu and <emphasis>preferences</emphasis>
(accessible from the <guimenuitem>Preferences</guimenuitem> option in
<guimenu>Edit</guimenu>).
</para>

<para>
Session properties can be changed for each different session that you
use.  The intention is that these properties are those whose best
setting depends on the type of session you are working on.
</para>

<para>
Preferences are options which apply to all sessions.  They are options
which depend on your general style of working, and the set up of your
audio system.
</para>

<!-- You can make session properties sort of &lsquo;sticky&rsquo; by using template sessions -->

</section>
<section><title>Session properties</title>

<para>
Session properties are arranged into five groups, whose contents are
discussed below.
</para>

<section xml:id="sec-session-properties-timecode"><title>Timecode</title>

</section>
<section xml:id="sec-session-properties-fades"><title>Fades</title>

</section>
<section xml:id="sec-session-properties-media"><title>Media</title>

<para>
The <emphasis>audio file format</emphasis> section governs the sample format, bit
depth and file type that Ardour will use when recording audio.  The
sample format can be one of:
</para>

<itemizedlist>
<listitem>
32-bit floating point &mdash; this is the format that Ardour uses
internally for processing, and is the highest quality; it is,
arguably, of higher quality than is required for recording things.
The reason Ardour uses it internally is that processing 32-bit
floating point signals is efficient on modern processors, and the high
bit depth helps reduce potential problems caused by performing
processing operations on audio.
</listitem>
<listitem>
24-bit integer &mdash; as the name suggests; this is a common
recording format as it offers a very high dynamic range (144dB,
without taking dither into account).
</listitem>
<listitem>
16-bit integer &mdash; the bit depth used by standard audio CDs.
</listitem>
</itemizedlist>

The file format can be one of:

<itemizedlist>
<listitem>
Broadcast WAVE &mdash; an extension of the very common WAVE
(<code>.wav</code>) file format, often used in broadcast, which adds
some metadata to the standard WAVE format.
</listitem>
<listitem>
WAVE &mdash; the Microsoft WAVE format (commonly given a suffix of <code>.wav</code>)
</listitem>
<listitem>
WAVE-64 &mdash; a version of WAVE that can handle files of greater than 4Gb in size.
</listitem>
<listitem>
CAF &mdash; Core Audio Format, as developed by Apple Computer for use on Mac OS X.
</listitem>
</itemizedlist>

</section>
<section>
<title>Monitoring</title>

</section>
<section>
<title>Misc</title>


</section>

</section>
<section><title>Ardour preferences</title>

<section><title>Misc</title>

<section><title>DSP CPU Utilization</title>

<para>
If you run Ardour on a computer with more than one processor, or more
than one core, Ardour can make use of all the cores.  It does this by
running the processing of different tracks and busses on different
cores.  This option allows you to specify the number of cores or
processors that Ardour should use for signal processing.  This setting
will only take effect once you re-start Ardour.
</para>

</section>
<section><title>Undo</title>

<para>
Ardour saves information on the actions that you take in order that it
can undo them on request.  This information is also stored with the
session, so that it is available after closing and re-opening a
session.  This is very useful if make some mistake, or change your
mind about an edit.  Storing this information does require memory and
disk space, however, so these options allow you to specify how many
commands are stored in memory and how many are written to disk.
</para>

<para>
Tick <emphasis>verify removal of last capture</emphasis> if you would like Ardour to
require confirmation when you try to remove the last capture pass.
</para>

<para>
Enabling <emphasis>make periodic backups of the session file</emphasis> will cause
Ardour to make a backup copy of the session file within the session
directory every 2 minutes.
</para>

</section>
<section><title>Session management</title>

<para>
The <emphasis>always copy imported files</emphasis> option will force Ardour never
to offer you the option to embed files that you import; they will
always be copied into the session folder.
</para>

<para>
The <emphasis>default folder for new sessions</emphasis> is where Ardour will
initially suggest that you create new sessions.
</para>

<para>
<emphasis>Maximum number of recent sessions</emphasis> dictates the number of recent
sessions that Ardour will offer in the startup dialogue and also in
<guimenuitem>Recent&hellip;</guimenuitem> from the <guimenu>Session</guimenu> menu.
</para>

</section>
<section><title>Click</title>

<para>
This section allows you to specify the sound files that will be used
for the click; the &lsquo;emphasis&rsquo; audio file will be used for the first
beat of the bar.  The <emphasis>click gain level</emphasis> adjusts the volume of
the click.
</para>

</section>
<section><title>Automation</title>

</section>
</section>
<section><title>Transport</title>

<itemizedlist>
<listitem> <emphasis>Keep record-enable engaged on stop</emphasis> &mdash; selecting this
  option will mean that after a recording pass, the main session
  record-enable will remain switched on; otherwise it will be switched
  off when the transport stops.
</listitem><listitem> <emphasis>Stop recording when an xrun occurs</emphasis> &mdash; an xrun (see
  <xref linkend="sec-xruns"/>) during recording could well mean that the
  recording has been corrupted by a small (or not-so-small) pop or
  click.  If this option is enabled, recording will stop if an xrun is
  detected, which may be useful to draw the fact to your attention.
  It may <emphasis>not</emphasis> be desirable on long or unattended recording
  sessions!
</listitem><listitem> <emphasis>Create markers where xruns occur</emphasis> &mdash; a less drastic
  option for observing xruns is to enable this option, which creates a
  marker wherever in a session an xrun occurs during recording.  The
  marker makes it easy to check out the area later and inspect the
  damage.
</listitem><listitem> <emphasis>Stop at the end of the session</emphasis> &mdash; if this is enabled,
  the transport will stop at the end-of-session marker <!-- (does it
    stop during record too?) -->
</listitem><listitem> <emphasis>Do seamless looping} &mdash; <!-- hmm! --></emphasis>
</listitem><listitem> <emphasis>Primary clock delta to edit cursor</emphasis>
</listitem><listitem> <emphasis>Secondary clock delta to edit cursor</emphasis>
</listitem><listitem> <emphasis>Disable per-track record disarm while rolling</emphasis> &mdash; if
  this is enabled it will be impossible to disarm a track from
  recording while the transport is moving.  This may be useful as a
  safety feature to prevent unwitting clicks on record enable buttons
  from dropping tracks out of record.
</listitem><listitem> <emphasis>12dB gain reduction during fast-forward and fast-rewind</emphasis>
  &mdash; fast-forward/rewind can, by their nature, generate
  unpleasant-sounding transients and high-frequency content which may
  be trying to tired ears.  With this option enabled, Ardour will drop
  the output by 12dB when doing &lsquo;winds&rsquo;.
  </listitem>
</itemizedlist>

</section>
<section xml:id="sec-ardour-preferences-editor"><title>Editor</title>

<itemizedlist>
<listitem>
<emphasis>Link selection of regions and tracks</emphasis> &mdash; with this
  enabled, when a region is seleted its track will be too.
</listitem>
<listitem>
<emphasis>Move relevant automation when audio regions are moved</emphasis>
  &mdash; when enabled, this means that moving a region will also move any
  automation at the same time as that region.
</listitem>
<listitem>
<emphasis>Show meters on tracks in the editor</emphasis> &mdash; enable this to
  show meters next to the track controls area for each track.
  Disabling it will provide a slight drop in CPU load.
</listitem>
<listitem>
<emphasis>Use overlap equivalency for regions} &mdash; <!-- ?! --></emphasis>
</listitem><listitem> <emphasis>Make rubberband selection rectangle snap to the grid</emphasis>
  &mdash; when selecting things by dragging a &lsquo;rubberband&rsquo; or &lsquo;lassoo&rsquo;
  rectangle, this option makes that rectangle snap to any active grid.
</listitem><listitem> <emphasis>Show waveforms in regions</emphasis> &mdash; this option draws
  waveforms within audio regions.  Disable it to ease the load on your
  CPU a bit.
</listitem><listitem> <emphasis>Show gain envelopes in audio regions</emphasis> &mdash; enable this to
  display region gain lines (see <xref linkend="sec-audio-region-gain"/>)
</listitem><listitem> <emphasis>Waveform scale</emphasis> &mdash; this alters the scale used to plot
  audio waveforms within regions between linear and logarithmic (ie in
  dBs).
</listitem><listitem> <emphasis>Waveform shape</emphasis> &mdash; waveforms can either be plotted
  traditionally (so that negative excursions of the waveform are
  plotted as such), or rectified (so that negative excursions are
  drawn as positive ones).
</listitem><listitem> <emphasis>Show waveforms for audio while it is being recorded</emphasis> &mdash;
  disabling this will prevent Ardour from generating waveforms for
  regions during record; again, this will lighten the load on your CPU
  a bit.
</listitem><listitem> <emphasis>Show zoom toolbar</emphasis> &mdash; disable this to hide the zoom
  toolbar, which may help the editor window to fit better on small
  screens.
</listitem><listitem> <emphasis>Color regions using their track's color</emphasis> &mdash; this will
  draw the trim bar of each region using the same colour as has been
  assigned to its track. <!-- if not? -->
</listitem><listitem> <emphasis>Update editor window during drags of the summary</emphasis> &mdash; if
  this option is on, as you drag the view rectangle in the summary
  (see <xref linkend="sec-summary"/>) the editor will be updated
  instantly.  This can be a bit slow for complicated sessions; turning
  this option off will mean that the editor only updates when you
  finish the drag.
</listitem><listitem> <emphasis>Synchronise editor and mixer track order</emphasis> &mdash; with this
  option enabled the order of the tracks in the editor window will
  match the order in the mixer; with it turned off, the track order
  can be different.
</listitem><listitem> <emphasis>Synchronise editor and mixer selection</emphasis> &mdash; with this
  option turned on, selecting a track in the editor will select it in
  the mixer, and vice-versa; otherwise selections are independent.
</listitem><listitem> <emphasis>Name new markers</emphasis> &mdash; if this is set, when you click on
  &lsquo;New Marker&rsquo; in the <emphasis>Locations</emphasis> window (or the locations editor
  list), the newly-created marker's name will be set to get the
  keyboard focus so that you can name it easily.
  </listitem>
</itemizedlist>

</section>
<section>
<title>Audio</title>

<section>
<title>Replicate missing region channels</title>

</section>
<section>
<title>Buffering</title>

<para>
These options govern how much memory Ardour will use to buffer signals
going out for playback, and coming in for record.  Larger buffers
provide more &lsquo;safety&rsquo;, in that there is more data prepared to cope
with temporary slowness with your hard discs, but require more memory.
It is not uncommon to set rather long capture buffer lengths (around a
minute or more) to help ensure trouble-free recordings.
</para>

</section>
<section><title>Monitoring</title>

<para>
The options here are:
</para>

<itemizedlist>
<listitem>
<emphasis>Use a monitor bus</emphasis> &mdash; as discussed in
  <xref linkend="sec-mute-and-solo"/>, this instructs Ardour to use a
  monitor bus, allowing the AFL/PFL features and the more advanced &lsquo;monitor section&rsquo; in the mixer window.
</listitem>
<listitem>
<emphasis>Record monitoring handled by</emphasis> &mdash; this
dictates how monitoring of incoming signals should be handled; this
can be by the audio hardware (in which case Ardour does nothing), by
JACK (in which case Ardour tells JACK how the monitoring should be) or
by Ardour (in which case Ardour does things itself).  See <xref linkend="sec-monitoring"/> for a full discussion.
</listitem>
</itemizedlist>

</section>
<section>
<title>Connection of tracks and busses</title>

<para>
These options provide some control of how Ardour helpfully tries to
automatically connect tracks and busses to appropriate places.
</para>

<para>
&lsquo;Auto-connect master/monitor busses&rsquo; will, if enabled, instruct Ardour to
automatically connect the outputs of the master and monitor busses to the first
N &lsquo;physical&rsquo; JACK ports, where N is the number of channels in
your master bus (e.g. 2 for stereo).  &lsquo;Physical&rsquo; JACK ports are
those that correspond to sound card outputs that get sound out into
the real world.
</para>

<!-- there is the monitor_bus_preferred_bundle but no-one sets it -->

<para>
&lsquo;Connect track inputs&rsquo; sets how new track inputs should be set up;
they can either be automatically connected to physical inputs or left
alone for you to connect yourself.
</para>

<para>
&lsquo;Connect track and bus outputs&rsquo; sets how new track and bus outputs
should be set up; they can either be connected automatically to
physical outputs, or to the master bus, or can be left alone for you to connect manually.
</para>

</section>
<section><title>Denormals</title>

<para>
&lsquo;Denormals&rsquo; are very small floating point numbers which can be
generated on occasion by Ardour and also by plugins.  On some CPUs, in
some situations, these can cause processing to slow down by a very
large factor (10 times or more).  This in turn can cause problems with
high CPU loads and xruns.
</para>

<sidebar>
<para>
The reason CPUs slow down is that in some cases they think it more
important to maintain precision with very small numbers than to
process them quickly.  This is true for many applications, but not for
audio.  The numbers involved are so small (usually around the
1e-16 range) that small errors in their processing are, in most
cases, inaudible.  For audio applications it is generally preferable
to lose some precision in order to keep things moving quickly.
</para>
</sidebar>

<para>
Ardour has a few strategies to deal with denormals, controlled by
these settings:
</para>

<itemizedlist>
<listitem>
<emphasis>Use DC bias to protect against denormals</emphasis> &mdash; this adds a
small DC value to strategic points in the signal processing chain.
This is not the most efficient way to do things, but can be helpful in
some circumstances.
</listitem>
<listitem>
<emphasis>Processor handling</emphasis> &mdash; most modern (post
year 2000) CPUs have configuration options themselves to help with
denormals.  These are called &lsquo;Flush to zero&rsquo; and &lsquo;Denormals are zero&rsquo;.
If these options are available on your machine (they will be
desensitized if not), it is worth enabling them both as they are
likely to solve the problem efficiently.
</listitem>
</itemizedlist>

</section>
<section><title>Plugins</title>

<itemizedlist>
<listitem> <emphasis>Silence plugins when the transport is stopped</emphasis> &mdash; when
  enabled, this option will &lsquo;flush&rsquo; all plugins when the transport is
  stopped.  This will prevent plugins such as delays and reverbs from
  continuing to sound when stop is pressed.
</listitem><listitem> <emphasis>Disable plugins during recording</emphasis> &mdash; this will turn off
  all plugins during recording, which may help to ensure trouble-free
  recordings if you have a complicated session which is running on the
  limits of your CPU power.
</listitem><listitem> <emphasis>Make new plugins active</emphasis> &mdash; enabling this option will
  make newly-added plugins active by default.
</listitem><listitem> <emphasis>Enable automatic analysis of audio</emphasis> &mdash; <!-- think this
  should be reworked -->
  </listitem>
</itemizedlist>

</section>
</section>
<section><title>Solo / mute</title>

<section><title>Solo-in-place mute cut</title>

<para>
When using &lsquo;solo-in-place&rsquo; (SiP), in other words when soloed tracks
are being listened to on the master bus, this fader specifies the gain
that will be applied to other tracks in order to mute them.  Setting
this level to &infin;dB will mean that other tracks will not be
heard at all; setting to some higher value less than 0dB means that
other non-soloed tracks will be heard, just reduced in volume compared
to the soloed tracks.
</para>

</section>
<section><title>Solo controls are Listen controls</title>

<para>
As discussed in detail in <xref linkend="sec-mute-and-solo"/>, enabling
this option makes solo buttons into listen controls (AFL or PFL).
This means that the &lsquo;solo&rsquo; (or now &lsquo;listen&rsquo;) buttons will not affect
the master bus, but instead will send the soloed tracks to the monitor
bus.
</para>

<para>
This option is desensitised if you are not using a monitor bus.
</para>

</section>
<section><title>Listen Position</title>

<para>
If &lsquo;Solo Controls are Listen controls&rsquo; is enabled, this option
specifies where the solo feed comes from; it can either be pre- or
post-fader.
</para>

</section>
</section>
<section><title>PFL signals come from</title>

<para>
If PFL is selected for the listen position, this drop-down specifies
precisely where the pre-fader signals come from.
</para>

</section>
<section><title>AFL signals come from</title>

<para>
If AFL is selected for the listen position, this drop-down specifies
precisely where the post-fader signals come from.
</para>

</section>
<section><title>Exclusive solo</title>

<para>
If this is enabled, only one track or bus will ever be soloed at once;
soloing track B while track A is currently soloed will un-solo
track A before soloing track B.
</para>

</section>
<section><title>Show solo muting</title>

<para>
If this is enabled, the mute button of tracks and busses will be drawn
outlined to indicate that the track or bus is muted because something
else is soloed.
</para>

</section>
<section><title>Soloing overrides muting</title>

<para>
If this is enabled, a track or bus that is both soloed and muted will
behave as if it is soloed.
</para>

</section>
<section><title>Mute affects&hellip;</title>

<para>
These options dictate whether muting the track will affect various
routes out of the track; through the sends, through the control
outputs (to the monitor bus) and to the main outputs.
</para>

</section>
<section><title>MIDI</title>
</section>
<section><title>User interaction</title>
</section>
<section><title>Interface</title>
</section>

</section>
</chapter>

<!-- ====================================================================================
     JACK
     ==================================================================================== -->

<chapter xml:id="ch-jack">
<title>JACK</title>
<indexterm><primary>JACK</primary></indexterm>

<section><title>Introduction</title>

<para>
JACK is the JACK audio connection kit.  It is a piece of software that
provides the low-level &lsquo;plumbing&rsquo; which allows Ardour to work.  Its
setup is crucial to Ardour; Ardour will not work without it.
</para>

<para>
JACK's essential task is to route audio and MIDI data to and from a
sound card, and also between applications.  It manages a set of
<emphasis>ports</emphasis>, which it can connect together in arbitrary ways.
<xref linkend="fig-typical-jack-session"/> gives a diagram of a vaguely
typical small JACK session.
</para>

<figure id="fig-typical-jack-session">
  <title>An example JACK session</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/typical-jack-session&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
In this diagram, the blue squares represent JACK <emphasis>ports</emphasis>.  These
are points which can be connected to, and are either input (they
accept data) or output (they produce data).  The black curved lines
represent connections between these ports.  The coloured boxes which
group things together are just for ease of viewing: to JACK,
everything is just a port.
</para>

<para>
The arrangement in the diagram shows some important features of JACK.
Firstly, any input can be connected to any output, without
restriction, and multiple inputs can be connected to a single output
(or vice versa).  Secondly, Ardour uses JACK for some of its
&lsquo;internal&rsquo; connections; we connect, for example, a track to the master
bus using JACK.  Thirdly, any JACK-supporting application can be
connected to any other; Ardour is just one of many.
</para>

<sidebar>
<para>
JACK is not limited to the standard concept of the &lsquo;sound card&rsquo;.  You
may choose to have no sound card at all (in which case JACK can run in
&lsquo;dummy&rsquo; mode).  It is also possible to send signals to and from JACK
over TCP/IP networks using netjack.  For simplicity, this manual will
assume that the user has a sound card in the conventional sense.
</para>
</sidebar>

<section>
<title>JACK and other audio software</title>

<para>
JACK is designed so that it uses a single sound-card, and has
exclusive control of that sound-card while it is running.  This is a
couple of consequences.  Firstly, if the sound card used to capture
audio is different from the one used to play it back, complications
arise.  Secondly, other software which tries to obtain exclusive
control of your sound-card, most notably &lsquo;pulseaudio&rsquo;, may interfere
with JACK's operation.
</para>


<section xml:id="sec-jack-multiple-cards">
<title>JACK with multiple sound cards</title>

<para>
If at all possible, it is a good idea to use JACK with a single sound
card.  Correctly using more than one card at the same time is
difficult.  The main reason for this difficulty is that JACK assumes
that all sound cards and programs that it is connecting are running
with synchronised sample clocks.  Arranging this is not easy if there
are two cards; there will be two unsynchronised sample clocks.
</para>

<para>
If you accept that using multiple sound cards is going to be
difficult, and you want to do it anyway, there are a number of
approaches.  These are described in <xref linkend="ch-advanced-jack"/>.
</para>

</section>
</section>
<section><title>Will my sound card work?</title>

For your sound card to work with JACK, must have a driver suitable for
the operating system that you are running on.  For Linux, this means
that your card must be supported by ALSA or FFADO; ALSA supports
drivers using a wide variety of interfaces, and FFADO is for firewire
soundcards only. 

<para>
The easiest way to check on ALSA compatibility is to visit <ulink url="http://www.alsa-project.org/main/index.php/Matrix:Main">http://www.alsa-project.org/main/index.php/Matrix:Main</ulink>.  This is the ALSA soundcard matrix and describes ALSA's
support for a variety of cards.  For FFADO, consult <ulink
url="http://www.ffado.org/?q=devicesupport/list">http://www.ffado.org/?q=devicesupport/list</ulink>
</para>

<para>
For Mac OS X, any card that is supported by the operating system
should work fine.
</para>

</section>
<section>
<title>JACK versions</title>

<para>
For historical reasons, there are two &lsquo;branches&rsquo; of JACK that are both
maintained, and can be used as drop-in replacements for each other.
JACK1 has version numbers like 0.121.3, and JACK2 (also known as
jackdmp) has version numbers like 1.9.8.  Both implementations have
their advantages and disadvantages.  It does not matter a great deal
which one you use.
</para>

</section>
</section>
<section>
<title>Starting JACK</title>

<para>
Ardour can start JACK automatically when it starts; and indeed many
users will find that this works perfectly well.  It is also possible
to start JACK manually, either at the command line or using a tool
such as QJackCtl<footnote><para><ulink url="http://qjackctl.sourceforge.net">http://qjackctl.sourceforge.net</ulink></para></footnote> (on
Linux) or JackPilot<footnote><para><ulink url="http://www.jackosx.com">http://www.jackosx.com/</ulink></para></footnote> (on Mac
OS X).
</para>

<section>
<title>Parameters</title>

<para>
JACK has many parameters which affect its operation.  Some of the more
important ones are discussed here.
</para>

<section>
<title>Sampling rate</title>

<para>
This is the number of samples per second that JACK will process, and
is important as it will govern the sampling rate that all audio
applications will run at.  The chosen rate must be supported
by the sound card, so values such as 44.1kHz, 48kHz, 96kHz
et. cetera are typical choices.  The higher the sampling rate, the
higher the theoretical audio frequency that the system can reproduce,
but also the more disk space will be consumed by audio recordings, and
the more CPU power will be required to run audio plugins.
</para>

<para>
The arguments about the best sampling rate are many, long and varied,
but can (in the humble opinion of the author) be summarised as: &lsquo;if in
doubt, use 44.1kHz for projects going to CD, or 48kHz for projects
going to film / video, as no-one can hear the difference between those
and anything higher (although they probably think they can)&rsquo;.
</para>

</section>
<section><title>Frames per period</title>

<para>
In a move necessary for efficiency, JACK does not process audio
sample-by-sample, but in blocks of samples.  The size of these blocks
can be selected when starting JACK.  A block is called a &lsquo;period&rsquo;,
and samples are often known as &lsquo;frames&rsquo; in the context of JACK.  If
the frames per period count is made smaller, the latency experienced
by sounds going into and coming out of the computer will be reduced;
on the other hand, smaller buffers make the computer work harder, and
may result in other problems if the computer is not well set-up.  It
is usually difficult to get below 64 frames per period on a typical
desktop computer, and values as high as 2048 frames per buffer are
perfectly acceptable if you do not particularly care about latency.
</para>

<sidebar>
<para>
The frames per period value governs how often JACK will talk to the
sound card.  If, for example, JACK is set to 64 frames per period, the
sound card will tell JACK when it has 64 new frames ready; JACK (and
therefore Ardour) must then respond before the next 64 frames arrives.
This has the consequences that JACK and Ardour are awoken more often,
causing a greater CPU load, and that the requirements for JACK's
response time are much more critical with smaller period sizes.  Some
systems will struggle to wake JACK up in time, making larger period
sizes more reliable on those systems.
</para>
</sidebar>

</section>
<section><title>Number of periods</title>

<para>
This value is related to the frames-per-period value above; 2 is
typical, and will work for most sound cards and systems.  It is worth
trying 3 here if problems are experienced.
</para>

</section>
</section>
</section>
<section>
<title>Troubleshooting JACK</title>

<section xml:id="sec-xruns">
<title>I am getting lots of xruns!</title>
<indexterm><primary>xrun</primary></indexterm>

<para>
An <emphasis>xrun</emphasis> is JACK's way of saying that the sound
card wanted attention, but JACK could not provide it quickly enough.
The causes of xruns are many and various.  The remainder of this
section lists some common causes of xruns.
</para>


<section>
<title>Buffer size or period count too small</title>

<para>
The JACK &lsquo;buffer size', or number of frames per period, governs how
often JACK has to talk to the sound card; smaller buffer sizes require
JACK to communicate with the sound card more often and with tighter
deadlines.  Increasing buffer size can be a simple way to reduce
xruns.  Generally speaking, the more advanced the sound card, the
lower the period size that it can be run with, but this does not
universally hold true.
</para>

<para>
Similarly, if you have a lot of xruns, particularly with a USB device,
try increasing JACK's period count from 2 to 3.
</para>

</section>
<section>
<title>JACK not running with real-time privileges</title>

<para>
JACK will try, by default, to obtain <emphasis>real-time</emphasis> scheduling
privileges when it starts.  If it suceeds, it means that the
operating system will treat JACK as higher priority than some other
tasks when it needs to talk to the soundcard, which is very likely to
reduce the incidence of xruns.
</para>

<para>
Some versions of Linux are careful about which tasks are allowed
real-time priviledges, as there is potential for such tasks to cause
problems with the system.  As a result, JACK may fail to obtain
real-time privileges, in which case your Linux configuration must be
altered to allow JACK to get what it wants.  For Debian- and
Ubuntu-based distributions, the best way is usually to add your user
to the &lsquo;audio&rsquo; group using
</para>

<programlisting>
usermod -a -G audio fred
</programlisting>

<para>
where <code>fred</code> is your user ID.  After this, configure the audio
group to be allowed appropriate settings by editing
<code>/etc/security/limits.conf</code> and adding
</para>

<programlisting>
@audio - rtprio 99
@audio - memlock unlimited
</programlisting>

<para>
to the bottom of of the file.  This allows members of the audio group
to start tasks with high real-time (RT) priority, and also allows them
to lock their memory into &lsquo;real&rsquo; memory; this is another step that
improves real-time performance.
</para>

<para>
After making these changes you will need to log out and log back in
again to see the effects.
</para>

</section>
<section>
<title>CPU frequency scaling</title>

<para>
Modern CPUs often have a feature called &lsquo;frequency scaling&rsquo;.  This is
the ability to lower the CPU's clock rate when it does not have much
to do, in order to save power.  This is especially useful in laptops
and mobile phones, as it can dramatically increase efficiency and
therefore battery life.
</para>

<para>
It is, however, known to be problematic if you are attempting
low-latency audio.  You should turn off frequency scaling if in any
doubt, and set your computer to run in a &lsquo;performance&rsquo; mode, where the
CPU is run at full speed constantly.
</para>

</section>
</section>
<section>
<title>I can play back but I cannot record, or vice versa</title>

<para>
This is commonly caused by JACK's prediliction for using only
one sound card.  If you are using different sound cards for playback
and record (which will be the case even if you are doing playback via
HDMI and recording via an on-board sound-card) you will need to set
JACK up to use multiple sound cards, as discussed in
<xref linkend="ch-advanced-jack"/>.
</para>

</section>
</section>
</chapter>

<!-- ====================================================================================
     UNFILED MISCELLANY
     ==================================================================================== -->

<chapter>
<title>Unfiled miscellany</title>

<section>
<title>MIDI binding maps</title>

<para>
MIDI binding maps provide a way to set up how a physical control
surface (such as a Behringer BCF2000 or Mackie Control) interacts with
Ardour.  An XML file is created to describe the mapping, and Ardour
loads it.  Maps for several devices are supplied with Ardour:
</para>

<itemizedlist>
<listitem>
Behringer BCF2000 (in native and Mackie Control modes)
</listitem>
<listitem>
Behringer DDX3216
</listitem>
<listitem>
Korg nano-Kontrol
</listitem>
<listitem>
M-Audio Oxygen 8 v2
</listitem>
<listitem>
M-Audio Axiom 25
</listitem>
<listitem>
Roland SI-24
</listitem>
<listitem>
EMU Xboard61
</listitem>
</itemizedlist>

<para>
This chapter describes the format of the maps and how to create your own.
</para>


<section>
<title>File basics</title>

<para>
MIDI bindings are stored in files with the suffix <code>.map</code>
attached to their name. The minimal content looks like this:
</para>

<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;ArdourMIDIBindings version="1.0.0" name="The name of this set of bindings">
&lt;/ArdourMIDIBindings>
&lt;/programlisting>
</programlisting>

The remainder of the file gives the bindings themselves, describing
the two parts of each binding: MIDI data that your controller sends,
and things that Ardour does in response.

<para>
A binding is an XML node called <code>&lt;Binding></code>.  The properties of the
node give the details of the binding.  
</para>

</section>
<section>
<title>Finding out what your MIDI control surface sends</title>

This is the most complex part of the job, but it's still not very hard.
You need to connect the control surface to an application that will
show you the information that the device sends each time you modify a
knob, slider, button etc.  There are a variety of such applications;
most notably gmidimon and kmidimon.  You can also use Ardour for this:

<orderedlist>
<listitem>
Select <guimenuitem>MIDI Tracer</guimenuitem> from the <guimenu>Window</guimenu> menu.
</listitem>
<listitem>
Choose &lsquo;MIDI Control In&rsquo; from the Port selector.
</listitem>
<listitem>
Use the MIDI connection matrix to connect Ardour's
MIDI Control In port to the MIDI port that your control surface is
sending data in on.
</listitem>
<listitem> Then watch the control surface's MIDI data appear
in the MIDI Tracer window as you twiddle knobs or push buttons.
</listitem>
</orderedlist>


</section>
<section>
<title>Describing MIDI in the binding file</title>

<para>
The properties for specifying the MIDI data in a <code>&lt;Binding></code>
node are as follows:
</para>

<itemizedlist>
<listitem> <code>channel="c" ctl="m"</code> &mdash; a continuous controller message m arriving on channel c.
</listitem><listitem> <code>channel="c" note="n"</code> &mdash; a note-on message for note n arriving on channel c.
</listitem><listitem> <code>channel="c" pgm="p"</code> &mdash; a program change message to program p arriving on channel c.
</listitem><listitem> <code>channel="c" pb="0"</code> &mdash; a pitch bend message on channel c.
</listitem><listitem> <code>sysex="a b c ..."</code> &mdash; a sequence of MIDI bytes a, b, c and so on that make up a system-exclusive message (as hexadecimal bytes)
</listitem><listitem> <code>msg="a b c ..."</code> &mdash; an arbitrary sequence of MIDI bytes a, b, c and so on (as hexadecimal bytes)
</listitem>
</itemizedlist>

</section>
<section><title>Binding to Ardour</title>

There are two basic kinds of bindings you can make between a MIDI
message and something inside Ardour. The first is a binding to a
specific parameter of a track or bus. The second is a binding to a
function that will change Ardour's state in some way. 


<section><title>Binding to track/bus controls</title>

A track/bus binding is a binding to an individual track or bus inside
Ardour.  Such a binding requires the name of the property to control,
which can be one of:

<itemizedlist>
<listitem> <code>/route/gain</code>
</listitem><listitem> <code>/route/solo</code>
</listitem><listitem> <code>/route/mute</code>
</listitem><listitem> <code>/route/recenable</code>
</listitem><listitem> <code>/route/send/gain</code>
</listitem><listitem> <code>/route/plugin/parameter</code>
</listitem>
</itemizedlist>

It then requires an address.  For track-level controls (solo, gain, mute, record-enable), the address is one of:

<itemizedlist>
<listitem> A number &mdash; the remote control ID of a track or bus
</listitem><listitem> The letter <emphasis>B</emphasis> followed by a number &mdash; the remote control ID of a track or bus within the current bank
</listitem><listitem> One or more words &mdash; the name of a track or bus
</listitem>
</itemizedlist>

For send, insert and plugin controls, the address consists of a track
or bus address followed by a number identifying the plugin or send
(starting from 1).  For plugin parameters, there is an additional third
component: a number identifying the plugin parameter number (starting
from 1).

For solo and mute bindings, you can also add <code>momentary="yes"</code> after the
control address. This is useful primarily for note-on bindings &mdash; when
Ardour gets the note-on it will solo or mute the targetted track or
bus, but then when a note-off arrives, it will un-solo or un-mute it.

The specification of a track or bus binding is put inside a <code>uri</code> property.  For example,

<programlisting>
&lt;Binding channel="1" ctl="20" uri="/route/gain 2">
</programlisting>

binds a control change on controller 20, channel 1 to the gain of track 2.  As another example

<programlisting>
&lt;Binding channel="4" note="20" uri="/route/recenable B5">
</programlisting>

binds a note-on for note 20 on channel 4 to the record-enable state of
the 5th track in the current bank.


</section>
</section>
<section><title>Binding to Ardour &lsquo;functions&rsquo;</title>

Rather than binding to a specific track/bus control, it may be useful
to have a MIDI controller able to alter some part of Ardour's state. A
binding definition that does this looks like this:

<programlisting>
&lt;Binding channel="1" note="13" function="transport-roll"/>
</programlisting>

<para>
In this case, a note-on message for note number 13 (on channel 1) will
start the transport rolling. The following function names are
available:
</para>

<itemizedlist>
<listitem>
<code>transport-stop</code> &mdash; stop the transport 
</listitem>
<listitem>
<code>transport-roll</code> &mdash; start the transport &lsquo;rolling&rsquo;
</listitem>
<listitem>
<code>transport-zero</code> &mdash; move the playhead to the zero position 
</listitem>
<listitem>
<code>transport-start</code> &mdash; move the playhead to the start marker 
</listitem>
<listitem>
<code>transport-end</code> &mdash; move the playhead to the end marker 
</listitem>
<listitem>
<code>loop-toggle</code> &mdash; turn on loop playback 
</listitem>
<listitem>
<code>rec-enable</code> &mdash; enable the global record button 
</listitem>
<listitem>
<code>rec-disable</code> &mdash; disable the global record button 
</listitem>
<listitem>
<code>next-bank</code> &mdash; move track/bus mapping to the next bank (see &lsquo;banks&rsquo; below) 
</listitem>
<listitem>
<code>prev-bank</code> &mdash; move track/bus mapping to the previous bank (see &lsquo;banks&rsquo; below) 
</listitem>
</itemizedlist>

</section>
<section>
<title>Binding to Ardour &lsquo;actions&rsquo;</title>

<para>
You can also bind a sysex or arbitrary message to any of the items
that occur in Ardour's main menu (and its submenus). The best place to
look for the (long) list of how to address each item is in your
keybindings file, which will contain lines that look like this:
</para>

<programlisting>
(gtk_accel_path "&lt;Actions>/Editor/temporal-zoom-in" "equal")
</programlisting>

To create a binding between an arbitrary MIDI message (we'll use a
note-off on channel 1 of MIDI note 60 (hex) with release velocity 40
(hex)), the binding file would contain:

<programlisting>
&lt;Binding msg="80 60 40" action="Editor/temporal-zoom-in"/>
</programlisting>

<para>
The general rule when taking an item from the keybindings file and
using it in a MIDI binding is to strip the &lt;Action> prefix of
the second field in the keybinding definition.
</para>

</section>
<section>
<title>Banks and banking</title>

Because many modern control surfaces offer per-track/bus controls for
far fewer tracks and busses than many users want to control, Ardour
offers the relatively common place concept of &lsquo;banks&rsquo;. Banks to allow
you to relatively easily control any number of tracks and/or busses
regardless of how many faders/knobs etc. your control surface has. To
use banking, the control addresses must be specified using the bank
relative format mentioned above (&lsquo;B1&rsquo; to identify the first track of a
bank of tracks, rather than &lsquo;1&rsquo; to identify the first track).

One very important extra piece of information is required to use
banking: an extra line near the start of the list of bindings that
specifies how many tracks/busses to use per bank. If the device has 8
faders, then 8 would be a sensible value to use for this. The line
looks like this:

<programlisting>
&lt;DeviceInfo bank-size="8"/>
</programlisting>

<para>
In addition, you probably want to ensure that you bind something on
the control surface to the next-bank and prev-bank functions,
otherwise you and other users will have to use the mouse and the GUI
to change banks, which rather defeats the purpose of the bindings.
</para>

</section>
<section>
<title>Motorised controls</title>

<para>
If your surface's controls are motorised, so that Ardour can move your physical controls,
add
</para>

<programlisting>
motorised="yes"
</programlisting>

<para>
to your <code>&lt;DeviceInfo></code> node, so that it reads something like
</para>

<programlisting>
&lt;DeviceInfo bank-size="8" motorised="yes">
</programlisting>

This will make Ardour more efficient in handling your controls.

</section>
<section><title>A complete (though muddled) example</title>

<programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?>
<ArdourMIDIBindings version="1.0.0" name="pc1600x transport controls">
<DeviceInfo bank-size="16"/>
<Binding channel="1" ctl="1"   uri="/route/gain B1"/>
<Binding channel="1" ctl="2"   uri="/route/gain B2"/>
<Binding channel="1" ctl="3"   uri="/route/send/gain B1 1"/>
<Binding channel="1" ctl="4"   uri="/route/plugin/parameter B1 1 1"/>
<Binding channel="1" ctl="6"   uri="/bus/gain master"/>

<Binding channel="1" note="1"  uri="/route/solo B1"/>
<Binding channel="1" note="2"  uri="/route/solo B2" momentary="yes"/>

<Binding channel="1" note="15"  uri="/route/mute B1" momentary="yes"/>
<Binding channel="1" note="16"  uri="/route/mute B2" momentary="yes"/>

<Binding sysex="f0 0 0 e 9 0 5b f7" function="transport-start"/>
<Binding sysex="f0 7f 0 6 7 f7" function="rec-disable"/>
<Binding sysex="f0 7f 0 6 6 f7" function="rec-enable"/>
<Binding sysex="f0 0 0 e 9 0 53 0 0 f7" function="loop-toggle"/>

<Binding channel="1" note="13" function="transport-roll"/>
<Binding channel="1" note="14" function="transport-stop"/>
<Binding channel="1" note="12" function="transport-start"/>
<Binding channel="1" note="11" function="transport-zero"/>
<Binding channel="1" note="10" function="transport-end"/>
</ArdourMIDIBindings>
</programlisting>

Please note that channel, controller and note numbers are specified as
decimal numbers in the ranges 1-16, 0-127 and 0-127 respectively.

</section>
</section>
<section><title>The processor list</title>

<para>
Each track or bus in Ardour has a list of <emphasis>processors</emphasis> that
operate on the audio or MIDI signal passing through it.  The operation
of the processor list is illustrated in
<xref linkend="fig-basic-processor-list"/>.
</para>

<figure id="fig-basic-processor-list"> 
  <title>Basic structure of a track or bus</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/basic-processor-list&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Audio or MIDI data arrives from a file on disk, or from the input
ports, depending on the monitoring settings that are in effect.  It is
then passed through each processor in sequence, before being panned
and sent to the output ports.
</para>

<para>
The term &lsquo;processor&rsquo; is a very general one.  It includes:
</para>

<itemizedlist>
<listitem> Plugins (LADSPA, LV2, VST etc.)
</listitem><listitem> Sends and returns
</listitem><listitem> The fader
</listitem><listitem> The meter
</listitem>
</itemizedlist>

<para>
Some processors are shown in the Ardour's mixer strip, and some are
hidden.  Consider the example mixer strip shown in <xref linkend="fig-processor-box"/>.
</para>

<figure id="fig-processor-box"> 
  <title>The processor box</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="screenshots/processor-box&scs;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Here we see five visible processors; they are:
</para>

<orderedlist>
<listitem> &lsquo;Autotalent'; a plugin.  This is coloured red to indicate
  that it is pre-fader.
</listitem>
<listitem> The fader.  This is where the mixer fader's gain is applied.
</listitem>
<listitem> Invada High Pass; a plugin.
</listitem>
<listitem> 4-band parameteric; another plugin.  The symbol between the
  high-pass and the parametric indicates that the signal is being
  split from mono to stereo, as the parametric is a stereo plugin.
</listitem>
<listitem>
TAP dynamics; another plugin.
</listitem>
</orderedlist>

<para>
Some processors are not shown on this list:
</para>

<itemizedlist>
<listitem> The meter; a processor which assesses the level of the signal at
  its point in the processor chain.
</listitem><listitem> A send to the main output.
</listitem><listitem> A send to the monitor bus, if one is being used.
</listitem>
</itemizedlist>


</section>
<section><title>Operations on the processor list</title>

<para>
The processor list in each mixer strip can be manipulated in several
different ways.
</para>

<para>
Firstly, processors can be re-ordered using drag-and-drop.  Dragging a
processor allows it to be moved around within the chain, or copied to
another processor list on another track or bus.
</para>

<para>
Secondly, processors can be enabled or disabled.  To the left of the
name of each processor is a small LED symbol; if this is lit-up, the
processor is active.  Clicking on it will deactivate the processor.
It will still pass audio or MIDI signals, but they will not be
affected.
</para>

<para>
Finally, processors can be added to or removed from the chain.
Right-clicking the processor list does three things:
</para>

<itemizedlist>
<listitem> A gap is opened up to indicate the location of the click.  The
  gap shows where any new processors will be inserted.
</listitem><listitem> The processor under the click is selected.
</listitem><listitem> A menu is presented giving options of what to do.
</listitem>
</itemizedlist>

<para>
From the menu, some new processors can be inserted.  These can be
plugins, sends or internal sends.  The selected processor can also be
deleted or copied.
</para>

</section>
<section><title>Tracks and busses in detail</title>

<sidebar>
<para>
This section goes into somewhat unhealthy detail about how tracks and
busses operate internally.  It may be of interest to almost nobody.
</para>
</sidebar>

<para>
Tracks and busses in Ardour share a common basis; they are both
pathways through which audio and MIDI data can pass, experiencing
various processing and distribution along the way.  The only real
difference between a track and a bus is that a track can either obtain
its input from a JACK port, or from files on disk; a bus has no disk
files, so only processes signals coming from other parts of Ardour, or
from other programs via JACK.
</para>

<para>
Internally, Ardour uses the term &lsquo;route&rsquo; to describe a bus, with a
track being a superset of the route's functionality (to include the
parts which read from and write to disk).  This chapter uses the word
&lsquo;route&rsquo; to indicate either a track or a bus, where the two have the
same behaviour.
</para>

<para>
Not all of the processing that signals experience as they travel
through routes is visible in the Ardour user-interface. The visible parts
are the plugins, the fader, the meter and (if present) the panner.
There are other invisible processes that happen to support Ardour's
internal operation.  <xref linkend="fig-route-in-detail"/> gives a
representation of the entire pathway of a route.
</para>

<figure id="fig-route-in-detail"> 
  <title>Detailed view of a route</title> 
  <mediaobject>
    <imageobject> 
      <imagedata fileref="diagrams/route-in-detail&dia;"/>
    </imageobject> 
  </mediaobject>
</figure>

<para>
Audio or MIDI data starts from either a set of JACK ports or a disk
file.  Busses always take their initial data from JACK ports, and
tracks can do either depending on monitoring settings.  It is possible
for tracks and busses to have no input, in which case the signal
starts off as silence.
</para>

<para>
If a track is recording, data is taken straight from the JACK input
ports and recorded; no processing on track will have any effect on the
recorded signal.
</para>

<para>
The signal then enters the processing chain.  Internally, this chain
is a set of &lsquo;processors&rsquo; connected in series.  Some processors are put
in place by Ardour, and some are at the whim of the user.
</para>

<section><title>Export</title>

<!-- XXX -->

</section>
<section><title>Internal return</title>

<para>
This is the point at which internal send signals from other routes
appears in the route being sent to.  This processor gathers signals
from all its connected sends and mixes them with the signal in the
route at that point.
</para>

</section>
<section><title>Monitor control</title>

<!-- XXX -->

</section>
<section><title>Monitor send</title>

<para>
The monitor send is an internal send which sends the route's signal,
whever it is located, to the monitor bus.  The monitor send is located
in different places, depending on the settings for AFL and PFL.
</para>

</section>
<section><title>Meter</title>

<para>
The meter processor passes signals unaltered, but meters them on the
way through.  It can be moved around depending on the meter point settings.
</para>

</section>
<section><title>User processors</title>

<para>
These are the &lsquo;conventional&rsquo; user-visible processors: plugins and
internal sends to other tracks or busses.
</para>

</section>
<section><title>Amp</title>

<para>
This is a gain-control element which is controlled by the fader.
</para>

</section>
<section><title>Main out</title>

<para>
This processor takes the route's signal, optionally pans it, and then
passes it to a set of JACK ports; this represents the main output of
the route.
</para>

</section>
</section>
</chapter>

<chapter xml:id="ch-advanced-jack">
<title>Advanced JACK</title>

<section><title>Using JACK with multiple sound cards</title>

<para>
If you want to set up JACK to use multiple sound cards at the same
time, there are a number of options:
</para>

<orderedlist>

<listitem>
Use the <code>alsa_in</code> and <code>alsa_out</code> clients (Linux and ALSA only)

<para>
If you are using JACK on Linux and want to use additional devices that
have ALSA driver support (i.e. most PCI, USB and Bluetooth devices),
then this is the best option.
</para>

<para>
<code>alsa_in</code> and <code>alsa_out</code> are two clients written by
Torben Hohn that make a single ALSA device appear as a set
of JACK ports. They both use Erik de Castro Lopo's libsamplerate
library to do any resampling required to keep the audio in sync as the
clocks of each device drift over time.
</para>

<para>
To use them, you start JACK as normal. Then you start an instance of
<code>alsa_in</code> or <code>alsa_out</code> for each additional device
(and &lsquo;direction&rsquo;) that you want to use. <code>alsa_out</code> will create
a set of ports representing the playback capabilities of the device,
and <code>alsa_in</code> will represent the capture/recording
capabilities. These two clients must be run inside a terminal window; 
there is no GUI for either of them. They both take arguments very much
like those of the JACK ALSA backend, with some additional controls
that affect the way that resampling is done. Full details are
available in the manual pages for each client, which you can read in a
terminal window with the command
</para>

<programlisting>
man alsa_in
</programlisting>

This page covers both clients, since their arguments are identical.

Note that you can use these clients even if you are running JACK with
a FFADO-supported device. The requirement for ALSA support only
applies to the extra devices you want to use, not the one that JACK
itself is using.

</listitem>
<listitem> Use the JACK2 audio adapter(s) (Jack2 only)

% XXX More information is needed on this option

</listitem>
<listitem> Using OS facilities to merge devices into a single pseudo-device

Both OS X and Linux provide ways to configure your machine so that it
appears to have a new audio device that is actually a combination of
one or more real devices. You can use this approach to create the
configuration you want to use and then start up JACK using that new
&lsquo;pseudo&rsquo; device.

<itemizedlist>
<listitem>OS X

You must perform these steps as a user with administrative
privileges. The first thing to do is to open up
<guimenuitem>Audio/MIDI Setup</guimenuitem> in the
<guimenu>Utilities</guimenu> submenu of
<guimenu>Applications</guimenu>. Go to the main menu bar, click on
<guibutton>Audio</guibutton> and then select <guimenu>Open aggregate
device editor</guimenu>. Follow the simple instructions to add the
each desired playback or capture device to your new aggregate
device. Then pick a name for the new device. This is the name you will
also use to choose the device for use with JACK.

<para>
Note that there are quite a few subtle bugs with Apple's &lsquo;aggregate
device&rsquo; facilities. Various things can happen that will cause the
device to lose all of its playback channels or all of its capture
channels, for example. If this happens, it is generally necessary to
close all applications that are using any audio devices, and quite
often a reboot is required.
</para>

<para>
Starting with JACK2 version 1.9.6, the CoreAudio backend can now
dynamically create &lsquo;aggregate devices&rsquo; when needed (like when the -C
and -P arguments are used to specify the separated input and output
devices).
</para>

</listitem>
<listitem>
Linux

You will need to use a text editor to create or add to your
<code>~/.asoundrc</code> file. This file is read by any ALSA application
(including JACK, if its using the ALSA backend) and can be used to
define pseudo-devices of many different kinds. The key idea here is
that you're going to define a new pseudo-device composed of 2 or more
other devices. In our example, we'll just focus on 2 devices being
merged into 1, where both devices have just 2 channels in and
out. This is the text you need to make sure is in <code>~/.asoundrc</code> (below,
we describe what this does):

<programlisting>
pcm.merge {
    type multi;
    slaves.a.pcm hw:0
    slaves.a.channels 2;
    slaves.b.pcm hw:1
    slaves.b.channels 2;
    bindings.0.slave a;
    bindings.0.channel 0;
    bindings.1.slave b;
    bindings.1.channel 0;
    bindings.2.slave a;
    bindings.2.channel 1;
    bindings.3.slave b;
    bindings.3.channel 1;
}
</programlisting>

</listitem>
</itemizedlist>

<para>
Lets see what this does:
</para>

<itemizedlist>
<listitem>
It defines a new audio pseudo-device called &lsquo;merge&rsquo;. You can use
  this name anywhere you might use the name of an ALSA audio device,
  such as <code>hw:0</code> or <code>hw:HDA</code> or <code>hw:DSP</code> or
  <code>plughw:1</code>.
</listitem>
<listitem>
It names <code>hw:0</code> as the first component (or &lsquo;slave&rsquo;) of
  this pseudo-device (<code>slave.a.pcm</code>) and <code>hw:1</code> as the
  second component (<code>slave.b.pcm</code>)
</listitem>
<listitem>
It states that the pseudo-device will use 2 channels from the
  first component and 2 channels from the 2nd component.
</listitem>
<listitem>
The lines containing <code>binding.</code> list, in order, which
channel of which component will correspond to the 4 channels of the
pseudo-device. In the mapping shown above, the first channel comes
from the first component, then the 2nd channel from the 2nd
component, the 3rd from the first component and the 4th from the
second component.
</listitem>
</itemizedlist>

<para>
Note that numbering of devices and channels in ALSA starts at zero,
not one.
</para>

<para>
The most important and complex part of the above definition is the
channel mappings defined by the bindings lines. A full channel mapping
definition consists of a pair of a lines of the following general
form:
</para>

<programlisting>
bindings.CHANNEL_OF_PSEUDO_DEVICE.slave SLAVE_DEVICE_THAT_WILL_PROVIDE_THIS_CHANNEL
bindings.CHANNEL_OF_PSEUDO_DEVICE.channel CHANNEL_OF_SLAVE_DEVICE_THAT_WILL_PROVIDE_THIS_CHANNEL
</programlisting>

<para>
So the specific pair of lines:
</para>

<programlisting>
bindings.0.slave a;
bindings.0.channel 0;
</programlisting>

<para>
mean that &lsquo;channel 0 of the pseudo-device will correspond to channel 0
of the first slave device'. Obviously by playing with this definition
you can create all sorts of wierd and wonderful mappings from the real
physical device channels to the pseudo-device channels. You probably
don't want to do that, though. The example above shows the most common
example: take the first N channels from the first device, and the
second M channels from the second device.
</para>

<para>
In theory, the above is enough to define a new pseudo-device, but many
applications, including JACK's ALSA backend, also want to open a
&lsquo;control device&rsquo; associated with the audio playback device. This is
where they can find out (and possibly control) various hardware
parameters associated with the device. Unfortunately there is no way
to merge these together in the same way, so we have to provide a
&lsquo;dummy&rsquo; control device definition that will keep such applications
happy. This definition looks like this:
</para>

<programlisting>
ctl.merge {
    type hw
    card 0
}
</programlisting>

<para>
Notice that name following the <code>ctl.</code> text must be the same as
the name following <code>pcm.</code> in the device definition above. The
control device definition we've given here effectively means <quote>if you
want to open the control device associated with &lsquo;merge', open the
control device associated with the first installed audio/MIDI
device</quote>. This probably isn't right of course &mdash; &lsquo;merge&rsquo; involves two
cards &mdash; but it will generally work just fine.
</para>

<para>
You can use this same approach to merge more than 2 devices - the
resulting <code>pcm.DEVICE-NAME</code> specification will obviously
include more lines. You can also use different devices than we did
above, where we just used the first and second installed card.
</para>

<para>
Note that you are likely to be better off using <code>hw:CARD</code> device names,
rather than <code>hw:N</code> names, when defining a &lsquo;multi&rsquo; pseudo-device, as
explained here. But further note that if you are using multiple
instances of the same type of audio hardware (say, 4 RME Multiface
devices), you will have to use <code>hw:N</code> because every card will have the
same <code>CARD</code> name. In fact, with such hardware, it may be very
difficult to ensure that <code>hw:0</code> always refers to the same audio
interface, because there is no ALSA name that uniquely defines a
particular PCI slot. This is currently an unsolved problem when using
multiple identical devices. If you use PCI (or PCIe or PCIx or other
derivatives of PCI) devices, the chances are that the first card will
always be the same one, and so forth, so its not likely to be an
issue. If you use several identical USB devices, it may be a more
significant problem.
</para>

</listitem>
<listitem>
Using the <code>-P</code> and <code>-C</code> arguments to a JACK backend

<para>
Several JACK backends, including the ALSA, FFADO and CoreAudio
versions, support the <code>-P</code> and <code>-C</code> arguments that can
be used to specify two different devices, one for playback and one for
capture/recording. You cannot use this to merge multiple devices for
playback or capture. This approach will not do any clock drift
correction, so as the two devices drift over time, you may get
glitches in the audio stream. Nevertheless, it can be an easy if
unreliable way to set up JACK so that, for example, it records from a
USB microphone and plays back via a builtin audio device.
</para>

<para>
When using <code>-P</code> or <code>-C</code> to specify different devices, do
not use the <code>-d</code> argument (which specifies a single device) and
do not use the <code>-D</code> argument (which tells JACK to configure a
device for playback and capture).
</para>
</listitem>
</orderedlist>
</section>
</chapter>
</book>
